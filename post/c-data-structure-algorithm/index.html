<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <script type="application/javascript" src='https://looechao.github.io/js/theme-mode.js'></script>
    <link rel="stylesheet" href='https://looechao.github.io/css/frameworks.min.css' />
    <link rel="stylesheet" href='https://looechao.github.io/css/github.min.css' />
    <link rel="stylesheet" href='https://looechao.github.io/css/github-style.css' />
    <link rel="stylesheet" href='https://looechao.github.io/css/light.css' />
    <link rel="stylesheet" href='https://looechao.github.io/css/dark.css' />
    <link rel="stylesheet" href='https://looechao.github.io/css/syntax.css' />
    <title>常用的数据结构和算法 - looechao&#39;s blog</title>
    
    <link rel="icon" type="image/x-icon" href='/images/favicon.png'>
    
    <meta name="theme-color" content="#1e2327">

    
    <meta name="description"
  content="动态数组，链表，栈，队列，哈希表，位图，二叉树，排序，二分查找" />
<meta name="keywords"
  content='blog, google analytics' />
<meta name="robots" content="noodp" />
<link rel="canonical" href="https://looechao.github.io/post/c-data-structure-algorithm/" />


<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="常用的数据结构和算法 - looechao&#39;s blog" />
<meta name="twitter:description"
  content="动态数组，链表，栈，队列，哈希表，位图，二叉树，排序，二分查找" />
<meta name="twitter:site" content="https://looechao.github.io/" />
<meta name="twitter:creator" content="" />
<meta name="twitter:image"
  content="https://looechao.github.io/">


<meta property="og:type" content="article" />
<meta property="og:title" content="常用的数据结构和算法 - looechao&#39;s blog">
<meta property="og:description"
  content="动态数组，链表，栈，队列，哈希表，位图，二叉树，排序，二分查找" />
<meta property="og:url" content="https://looechao.github.io/post/c-data-structure-algorithm/" />
<meta property="og:site_name" content="常用的数据结构和算法" />
<meta property="og:image"
  content="https://looechao.github.io/">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">

<meta property="article:published_time" content="2024-05-10 22:53:13 &#43;0800 CST" />











</head>

<body>
  <div style="position: relative">
  <header class="Header js-details-container Details px-3 px-md-4 px-lg-5 flex-wrap flex-md-nowrap open Details--on">
    <div class="Header-item mobile-none" style="margin-top: -4px; margin-bottom: -4px;">
      <a class="Header-link" href="https://looechao.github.io/">
        <svg class="octicon" height="32" viewBox="0 0 16 16" version="1.1" width="32">
          <path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z">
          </path>
        </svg>
      </a>
    </div>
    <div class="Header-item d-md-none">
      <button class="Header-link btn-link js-details-target" type="button" onclick="document.querySelector('#header-search').style.display = document.querySelector('#header-search').style.display == 'none'? 'block': 'none'">
        <svg height="24" class="octicon octicon-three-bars" viewBox="0 0 16 16" version="1.1" width="24">
          <path fill-rule="evenodd" d="M1 2.75A.75.75 0 011.75 2h12.5a.75.75 0 110 1.5H1.75A.75.75 0 011 2.75zm0 5A.75.75 0 011.75 7h12.5a.75.75 0 110 1.5H1.75A.75.75 0 011 7.75zM1.75 12a.75.75 0 100 1.5h12.5a.75.75 0 100-1.5H1.75z">
          </path>
        </svg>
      </button>
    </div>
    <div style="display: none;" id="header-search" class="Header-item Header-item--full flex-column flex-md-row width-full flex-order-2 flex-md-order-none mr-0 mr-md-3 mt-3 mt-md-0 Details-content--hidden-not-important d-md-flex">
      <div class="Header-search header-search flex-auto js-site-search position-relative flex-self-stretch flex-md-self-auto mb-3 mb-md-0 mr-0 mr-md-3 scoped-search site-scoped-search js-jump-to">
        <div class="position-relative">
          <form target="_blank" action="https://www.google.com/search" accept-charset="UTF-8" method="get" autocomplete="off">
            <label class="Header-search-label form-control input-sm header-search-wrapper p-0 js-chromeless-input-container header-search-wrapper-jump-to position-relative d-flex flex-justify-between flex-items-center">
              <input type="text" class="Header-search-input form-control input-sm header-search-input jump-to-field js-jump-to-field js-site-search-focus js-site-search-field is-clearable" name="q" value="" placeholder="Search" autocomplete="off">
              <input type="hidden" name="q" value="site:https://looechao.github.io/">
            </label>
          </form>
        </div>
      </div>
    </div>

    <div class="Header-item Header-item--full flex-justify-center d-md-none position-relative">
      <a class="Header-link " href="site:https://looechao.github.io/">
        <svg class="octicon octicon-mark-github v-align-middle" height="32" viewBox="0 0 16 16" version="1.1" width="32">
          <path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z">
          </path>
        </svg>
      </a>
    </div>
    <div class="Header-item" style="margin-right: 0;">
      <a href="javascript:void(0)" class="Header-link no-select" onclick="switchTheme()">
        <svg style="fill: var(--color-profile-color-modes-toggle-moon);" class="no-select" viewBox="0 0 16 16" version="1.1" width="16" height="16">
          <path fill-rule="evenodd" clip-rule="evenodd" d="M4.52208 7.71754C7.5782 7.71754 10.0557 5.24006 10.0557 2.18394C10.0557 1.93498 10.0392 1.68986 10.0074 1.44961C9.95801 1.07727 10.3495 0.771159 10.6474 0.99992C12.1153 2.12716 13.0615 3.89999 13.0615 5.89383C13.0615 9.29958 10.3006 12.0605 6.89485 12.0605C3.95334 12.0605 1.49286 10.001 0.876728 7.24527C0.794841 6.87902 1.23668 6.65289 1.55321 6.85451C2.41106 7.40095 3.4296 7.71754 4.52208 7.71754Z">
          </path>
        </svg>
      </a>
    </div>
  </header>
</div>

  
<div>
  <main>
    <div class="gisthead pagehead bg-gray-light pb-0 pt-3 mb-4">
      <div class="px-0">
        <div class="mb-3 d-flex px-3 px-md-3 px-lg-5">
          <div class="flex-auto min-width-0 width-fit mr-3">
            <div class="d-flex">
              <div class="d-none d-md-block">
                <a class="avatar mr-2 flex-shrink-0" href="https://looechao.github.io/">
                  <img class=" avatar-user"
                    src="/images/profile.png"
                    width="32" height="32"></a>
              </div>
              <div class="d-flex flex-column">
                <h1 class="break-word f3 text-normal mb-md-0 mb-1">
                  <span class="author">
                    <a href="https://looechao.github.io/">Looe</a>
                  </span>
                  <span class="path-divider">/</span>
                  <strong class="css-truncate css-truncate-target mr-1" style="max-width: 410px">
                    <a href="https://looechao.github.io/post/c-data-structure-algorithm/">常用的数据结构和算法</a>
                  </strong>
                </h1>
                <div class="note m-0">
                  Created <relative-time datetime="Fri, 10 May 2024 22:53:13 &#43;0800"
                    class="no-wrap">
                    Fri, 10 May 2024 22:53:13 &#43;0800</relative-time>

                  
                  <span class="file-info-divider"></span>
                  Modified <relative-time datetime="Wed, 12 Jun 2024 09:00:51 &#43;0800"
                    class="no-wrap">
                    Wed, 12 Jun 2024 09:00:51 &#43;0800</relative-time>
                  
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container-lg px-3 new-discussion-timeline">
      <div class="repository-content gist-content">
        <div>
          <div class="js-gist-file-update-container js-task-list-container file-box">
            <div id="file-pytest" class="file my-2">
              <div id="post-header" class="file-header d-flex flex-md-items-center flex-items-start sticky-header" style="z-index: 2">
                <div class="file-info d-flex flex-md-items-center flex-items-start flex-order-1 flex-auto">
                  <div class="text-mono f6 flex-auto pr-3 flex-order-2 flex-md-order-1 mt-2 mt-md-0">
                    
                    <summary id="toc-toggle" onclick="clickToc()" class="btn btn-octicon m-0 mr-2 p-2">
                      <svg aria-hidden="true" viewBox="0 0 16 16" height="16" width="16" class="octicon octicon-list-unordered">
                        <path fill-rule="evenodd" d="M2 4a1 1 0 100-2 1 1 0 000 2zm3.75-1.5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zm0 5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zm0 5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zM3 8a1 1 0 11-2 0 1 1 0 012 0zm-1 6a1 1 0 100-2 1 1 0 000 2z"></path>
                      </svg>
                    </summary>
                    <details-menu class="SelectMenu" id="toc-details" style="display: none;">
                      <div class="SelectMenu-modal rounded-3 mt-1" style="max-height: 340px;">
                        <div class="SelectMenu-list SelectMenu-list--borderless p-2" style="overscroll-behavior: contain;" id="toc-list">
                        </div>
                      </div>
                    </details-menu>
                      11076 Words
                    

                  </div>
                  <div class="file-actions flex-order-2 pt-0">
                    
                    
                    <a class="muted-link mr-3" href="/tags/%E6%8A%80%E6%9C%AF">
                      <svg class="octicon octicon-tag" viewBox="0 0 16 16" version="1.1" width="16" height="16">
                        <path fill-rule="evenodd"
                          d="M2.5 7.775V2.75a.25.25 0 01.25-.25h5.025a.25.25 0 01.177.073l6.25 6.25a.25.25 0 010 .354l-5.025 5.025a.25.25 0 01-.354 0l-6.25-6.25a.25.25 0 01-.073-.177zm-1.5 0V2.75C1 1.784 1.784 1 2.75 1h5.025c.464 0 .91.184 1.238.513l6.25 6.25a1.75 1.75 0 010 2.474l-5.026 5.026a1.75 1.75 0 01-2.474 0l-6.25-6.25A1.75 1.75 0 011 7.775zM6 5a1 1 0 100 2 1 1 0 000-2z">
                        </path>
                      </svg>
                      技术
                    </a>
                    
                    <a class="muted-link mr-3" href="/tags/c/c&#43;&#43;">
                      <svg class="octicon octicon-tag" viewBox="0 0 16 16" version="1.1" width="16" height="16">
                        <path fill-rule="evenodd"
                          d="M2.5 7.775V2.75a.25.25 0 01.25-.25h5.025a.25.25 0 01.177.073l6.25 6.25a.25.25 0 010 .354l-5.025 5.025a.25.25 0 01-.354 0l-6.25-6.25a.25.25 0 01-.073-.177zm-1.5 0V2.75C1 1.784 1.784 1 2.75 1h5.025c.464 0 .91.184 1.238.513l6.25 6.25a1.75 1.75 0 010 2.474l-5.026 5.026a1.75 1.75 0 01-2.474 0l-6.25-6.25A1.75 1.75 0 011 7.775zM6 5a1 1 0 100 2 1 1 0 000-2z">
                        </path>
                      </svg>
                      C/C&#43;&#43;
                    </a>
                    
                    
                  </div>
                </div>
              </div>


              <div class="Box-body px-5 pb-5" style="z-index: 1">
                <article class="markdown-body entry-content container-lg"><h1 id="数据结构和算法">数据结构和算法</h1>
<h2 id="动态数组vector">动态数组（Vector）</h2>
<p>分析过程</p>
<ul>
<li>
<p>模型</p>
</li>
<li>
<p>基本操作</p>
<ul>
<li>
<p>增</p>
<p>一般在末尾添加</p>
</li>
<li>
<p>删</p>
<p>一般在末尾删除</p>
</li>
<li>
<p>查找</p>
<ul>
<li>根据索引查找值</li>
<li>查找与特定值相等的元素（有序用二分/无序顺序查找）</li>
</ul>
</li>
<li>
<p>遍历</p>
</li>
</ul>
</li>
<li>
<p>实现</p>
</li>
</ul>
<h2 id="链表">链表</h2>
<ul>
<li>数据域：存放数据</li>
<li>指针域：存放节点的地址</li>
</ul>
<h3 id="分类">分类</h3>
<ul>
<li>
<p>单向链表</p>
<p>最后一个节点的指针是空指针</p>
</li>
<li>
<p>单向循环链表</p>
<p>环形</p>
</li>
<li>
<p>双向链表</p>
<p>首节点的prev指针和尾节点的next指针为空</p>
</li>
<li>
<p>双向循环链表</p>
</li>
</ul>
<h3 id="单链表操作">单链表操作</h3>
<table>
<thead>
<tr>
<th style="text-align:center">操作</th>
<th style="text-align:center">复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">增(某个节点后面添加)</td>
<td style="text-align:center">O(1)</td>
</tr>
<tr>
<td style="text-align:center">删(某个节点后面删除)</td>
<td style="text-align:center">O(1)</td>
</tr>
<tr>
<td style="text-align:center">查（根据索引）</td>
<td style="text-align:center">O(n)</td>
</tr>
<tr>
<td style="text-align:center">查（与特定值相等的点）</td>
<td style="text-align:center">O(n)</td>
</tr>
<tr>
<td style="text-align:center">遍历</td>
<td style="text-align:center">O(n)</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>增：在某个节点后面添加</p>
<pre tabindex="0"><code>new_node-&gt;next=curr-&gt;next
curr-&gt;next = new_node;
</code></pre></li>
<li>
<p>删：在某个节点后面删除</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">curr</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span></code></pre></div></li>
<li>
<p>查：</p>
<ul>
<li>
<p>根据索引查找结点</p>
</li>
<li>
<p>查找与特定值相等的节点</p>
<ul>
<li>元素大小无序</li>
<li>元素大小有序</li>
</ul>
</li>
</ul>
</li>
<li>
<p>遍历：正向遍历</p>
</li>
</ul>
<h3 id="实现单链表">实现单链表</h3>
<p>list.h</p>
<pre tabindex="0"><code>NODE    []]-----&gt;[]]-----&gt;[]]----&gt;[]]----&gt;[]]
         ^                                 ^
         |                                 |
LIST   head                              tail
</code></pre><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="kt">int</span> <span class="n">E</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">node</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">E</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">node</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span><span class="n">Node</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">*</span> <span class="n">head</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">*</span> <span class="n">tail</span><span class="p">;</span>    
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span><span class="n">List</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//API
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">List</span><span class="o">*</span> <span class="nf">list_create</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">list_destroy</span><span class="p">(</span><span class="n">List</span><span class="o">*</span> <span class="n">list</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//插入
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">add_before_head</span><span class="p">(</span><span class="n">List</span><span class="o">*</span> <span class="n">list</span><span class="p">,</span> <span class="n">E</span> <span class="n">val</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">add_behind_head</span><span class="p">(</span><span class="n">List</span><span class="o">*</span> <span class="n">list</span><span class="p">,</span> <span class="n">E</span> <span class="n">val</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">add_node</span><span class="p">(</span><span class="n">List</span><span class="o">*</span> <span class="n">list</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="n">E</span> <span class="n">val</span><span class="p">)</span>
</span></span></code></pre></div><p>list.c</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span><span class="cpf">&#34;List.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">//API
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">List</span><span class="o">*</span> <span class="nf">list_create</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">calloc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">List</span><span class="p">));</span> <span class="c1">//创建并清零
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">list_destroy</span><span class="p">(</span><span class="n">List</span><span class="o">*</span> <span class="n">list</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//头插法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">add_before_head</span><span class="p">(</span><span class="n">List</span><span class="o">*</span> <span class="n">list</span><span class="p">,</span> <span class="n">E</span> <span class="n">val</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//1.创建新节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Node</span><span class="o">*</span> <span class="n">new_node</span> <span class="o">=</span> <span class="nf">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Node</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">new_node</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Error:malloc failed in add_before_head&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//2.初始化节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">new_node</span> <span class="o">-&gt;</span> <span class="n">data</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">new_node</span> <span class="o">-&gt;</span> <span class="n">next</span> <span class="o">=</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//3.更新链表的信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">list</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">		<span class="n">list</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">list</span><span class="o">-&gt;</span><span class="n">size</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">add_behind_head</span><span class="p">(</span><span class="n">List</span><span class="o">*</span> <span class="n">list</span><span class="p">,</span> <span class="n">E</span> <span class="n">val</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//1.创建新节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Node</span><span class="o">*</span> <span class="n">new_node</span> <span class="o">=</span> <span class="nf">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Node</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">new_node</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Error:malloc failed in add_behind_head&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//2.初始化节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">new_node</span> <span class="o">-&gt;</span> <span class="n">data</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">new_node</span><span class="o">-</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//new_node -&gt; next = list-&gt;NULL;空指针解引用异常
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//3.链接到尾部
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   	<span class="k">if</span><span class="p">(</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">list</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">list</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">list</span><span class="o">-&gt;</span><span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">list</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//4.更新链表的信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">list</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">		<span class="n">list</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">list</span><span class="o">-&gt;</span><span class="n">size</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">add_node</span><span class="p">(</span><span class="n">List</span><span class="o">*</span> <span class="n">list</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="n">E</span> <span class="n">val</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//参数校验
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Error:Illegal Argument: idx = %d, size = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">list</span><span class="o">-&gt;</span> <span class="n">size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nf">add_before_head</span><span class="p">(</span><span class="n">list</span><span class="p">,</span><span class="n">val</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">idx</span> <span class="o">==</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nf">add_behind_tail</span><span class="p">(</span><span class="n">list</span><span class="p">,</span><span class="n">val</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//在链表的中间插入
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//找索引为idx-1的节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//循环不变式，current和i对应
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//进入循环体前一直不变的关系
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Node</span><span class="o">*</span> <span class="n">curr</span> <span class="o">-</span> <span class="n">list</span> <span class="o">-&gt;</span> <span class="n">head</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">idx</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl"> 		<span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>       
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="c1">// i = idx - 1,curr指向索引为idx-1的节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//再curr后添加节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//1.创建新节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Node</span><span class="o">*</span> <span class="n">new_node</span> <span class="o">=</span> <span class="nf">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Node</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">new_node</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Error:malloc failed in add_behind_head&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//2.初始化节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">new_node</span> <span class="o">-&gt;</span> <span class="n">data</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">new_node</span><span class="o">-</span><span class="n">next</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//3.链接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">curr</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//4.修改链表的信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">list</span><span class="o">-&gt;</span><span class="n">size</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>main.c</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span><span class="cpf">&#34;List.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="c1">//单元测试
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">List</span><span class="o">*</span> <span class="n">list</span> <span class="o">=</span> <span class="nf">list_create</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nf">add_before_head</span><span class="p">(</span><span class="n">list</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">add_before_head</span><span class="p">(</span><span class="n">list</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">add_before_head</span><span class="p">(</span><span class="n">list</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">add_before_head</span><span class="p">(</span><span class="n">list</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="双链表">双链表</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">[</span>*<span class="o">][</span>D<span class="o">][</span>*<span class="o">]</span> &lt;<span class="o">====</span>&gt; <span class="o">[</span>*<span class="o">][</span>D<span class="o">][</span>*<span class="o">]</span> &lt;<span class="o">====</span>&gt; <span class="o">[</span>*<span class="o">][</span>D<span class="o">][</span>*<span class="o">]</span> 
</span></span></code></pre></div><ul>
<li>
<p>基本操作</p>
<ul>
<li>
<p>增：在某个节点前面添加0</p>
</li>
<li>
<p>删：删除当前节点</p>
</li>
<li>
<p>查</p>
<ul>
<li>根据索引查找值</li>
<li>查找特定值相等的点（无序O(n) / 有序）</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">//优化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Static</span> <span class="n">Node</span><span class="o">*</span> <span class="n">last</span><span class="p">;</span>  <span class="c1">//记录上一次查找的节点
</span></span></span></code></pre></div><table>
<thead>
<tr>
<th style="text-align:center">操作</th>
<th style="text-align:center">根据索引查</th>
<th style="text-align:center">遍历时间</th>
<th style="text-align:center">根据定值查</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">单链表</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">n/2</td>
<td style="text-align:center">效率低</td>
</tr>
<tr>
<td style="text-align:center">双链表</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">n/4</td>
<td style="text-align:center">效率高(优化)</td>
</tr>
</tbody>
</table>
<ul>
<li>查找前驱节点：O(1)</li>
</ul>
</li>
</ul>
</li>
<li>
<p>拓展 - 关于空间和时间</p>
<ul>
<li>空间换时间：缓存，缓冲</li>
</ul>
</li>
<li>
<p>时间换空间：压缩，交换区(swap area)</p>
</li>
<li>
<p>优点：</p>
<ul>
<li>效率高（空间换时间）</li>
</ul>
</li>
</ul>
<h3 id="常见面试题">常见面试题</h3>
<h4 id="1-求链表中间结点的值">1. 求链表中间结点的值</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">Eg1.
</span></span><span class="line"><span class="cl">   input: 1--&gt;2--&gt;3
</span></span><span class="line"><span class="cl">  output: <span class="m">2</span>
</span></span><span class="line"><span class="cl">Eg2.
</span></span><span class="line"><span class="cl">   input: 1--&gt;2--&gt;3--&gt;4
</span></span><span class="line"><span class="cl">  output: <span class="m">3</span>
</span></span></code></pre></div><ul>
<li>
<p>思路1</p>
<ul>
<li>遍历链表，求链表的长度n</li>
<li>求索引为n/2的节点</li>
</ul>
</li>
<li>
<p>思路2</p>
<ul>
<li>
<p>使用快慢指针fast和slow指针，</p>
</li>
<li>
<p>fast走两步，slow走一步</p>
</li>
<li>
<p>当fast到达末尾时，返回slow所指的结点</p>
<p><strong>注意短路原则</strong>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">fast-&gt;next <span class="o">==</span> NULL <span class="o">||</span> <span class="nv">fast</span> <span class="o">==</span> NULL <span class="o">(</span>x<span class="o">)</span>
</span></span><span class="line"><span class="cl">//fast-&gt;next <span class="o">==</span> NULL可能对空指针进行解引用
</span></span><span class="line"><span class="cl">//应该使用下面的方法
</span></span><span class="line"><span class="cl"><span class="nv">fast</span> <span class="o">==</span> NULL <span class="o">||</span> fast-&gt;next <span class="o">==</span> NULL <span class="o">(</span>V<span class="o">)</span>
</span></span></code></pre></div></li>
</ul>
</li>
</ul>
<h4 id="2-判断单链表是否有环">2. 判断单链表是否有环</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">[</span>1<span class="o">][</span>*<span class="o">]</span>---&gt;<span class="o">[</span>2<span class="o">][</span>*<span class="o">]</span>---&gt;<span class="o">[</span>3<span class="o">][</span>*<span class="o">]</span>---&gt;<span class="o">[</span>4<span class="o">][</span>*<span class="o">]</span>----&gt;NULL
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                     &lt;----------- ^
</span></span><span class="line"><span class="cl">                     <span class="p">|</span>            <span class="p">|</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>1<span class="o">][</span>*<span class="o">]</span>---&gt;<span class="o">[</span>2<span class="o">][</span>*<span class="o">]</span>---&gt;<span class="o">[</span>3<span class="o">][</span>*<span class="o">]</span>---&gt;<span class="o">[</span>4<span class="o">][</span>*<span class="o">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  &lt;------------------------------ ^
</span></span><span class="line"><span class="cl">  <span class="p">|</span>                               <span class="p">|</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>1<span class="o">][</span>*<span class="o">]</span>---&gt;<span class="o">[</span>2<span class="o">][</span>*<span class="o">]</span>---&gt;<span class="o">[</span>3<span class="o">][</span>*<span class="o">]</span>---&gt;<span class="o">[</span>4<span class="o">][</span>*<span class="o">]</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">hasCycle</span><span class="p">(</span><span class="k">struct</span> <span class="n">ListNode</span> <span class="o">*</span><span class="n">heaed</span><span class="p">);</span>
</span></span></code></pre></div><ul>
<li>
<p>思路1 - 迷雾森林</p>
<ul>
<li>用travelled存放：已遍历节点的指针</li>
<li>遍历节点：
<ul>
<li>判断当前节点curr, 是否在travelled集合
<ul>
<li>是：true;</li>
<li>否：将curr节点添加到travelled集合</li>
</ul>
</li>
<li>curr = NULL, false;</li>
</ul>
</li>
<li>时间：和集合travelled的查找算法相关，如果使用hashtable, 复杂度为O(n)</li>
<li>空间：O(n);</li>
</ul>
</li>
<li>
<p>思路2 - 快慢指针</p>
<p>可以类比跑道</p>
<hr>
<p>​               fast</p>
<p>                  ↓</p>
<p>  ↑</p>
<p>slow</p>
<hr>
<ul>
<li>
<p>如果是无环的，则fast和slow永远不可能相遇</p>
</li>
<li>
<p>若有环，fast和slow一定会再一次相遇</p>
</li>
<li>
<p>时间：O(n)，慢指针走不了一圈</p>
</li>
<li>
<p>空间：O(1)</p>
</li>
</ul>
</li>
</ul>
<h4 id="3-反转单链表">3. 反转单链表</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">ListNode</span><span class="o">*</span> <span class="nf">revereseList</span><span class="p">(</span><span class="k">struct</span> <span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">);</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">Eg1</span><span class="p">.</span>
</span></span><span class="line"><span class="cl">   <span class="nl">input</span><span class="p">:</span> <span class="mi">1</span><span class="o">--&gt;</span><span class="mi">2</span><span class="o">--&gt;</span><span class="mi">3</span>
</span></span><span class="line"><span class="cl">  <span class="nl">output</span><span class="p">:</span> <span class="mi">3</span><span class="o">--&gt;</span><span class="mi">2</span><span class="o">--&gt;</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="n">Eg2</span><span class="p">.</span>
</span></span><span class="line"><span class="cl">   <span class="nl">input</span><span class="p">:</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">  <span class="nl">output</span><span class="p">:</span> <span class="mi">1</span>
</span></span></code></pre></div><ul>
<li>
<p>思路1 - 头插法</p>
<p>遍历链表，依次反转每一个元素, 添加到新的链表中</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">    NULL    <span class="o">[</span>1<span class="o">][</span>*<span class="o">]</span>-----&gt;<span class="o">[</span>2<span class="o">][</span>*<span class="o">]</span>---&gt;NULL
</span></span><span class="line"><span class="cl">     ^       ^           ^
</span></span><span class="line"><span class="cl">     <span class="p">|</span>       <span class="p">|</span>           <span class="p">|</span>
</span></span><span class="line"><span class="cl">prev<span class="o">[</span>*<span class="o">]</span>     <span class="o">[</span>*<span class="o">]</span>curr     <span class="o">[</span>*<span class="o">]</span>next
</span></span></code></pre></div><ul>
<li>时间：O(n)</li>
<li>空间：O(1)</li>
</ul>
</li>
<li>
<p>思路2 - 递归</p>
<ul>
<li>
<p>边界条件：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="n">head</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">-&gt;</span> <span class="nb">NULL</span>
</span></span></code></pre></div></li>
<li>
<p>递归</p>
<p>在反转后n-1个节点的情况下，如何反转第一个节点</p>
</li>
<li>
<p>时间：O(n)</p>
</li>
<li>
<p>空间：O(n)</p>
</li>
</ul>
</li>
</ul>
<h4 id="4-合并两条有序单链表">4. 合并两条有序单链表</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">Eg1.
</span></span><span class="line"><span class="cl">   input: 1--&gt;3--&gt;5
</span></span><span class="line"><span class="cl">          2--&gt;4--&gt;6
</span></span><span class="line"><span class="cl">  output: 1--&gt;2--&gt;3--&gt;4--&gt;5--&gt;6
</span></span><span class="line"><span class="cl">Eg2.
</span></span><span class="line"><span class="cl">   input: 1--&gt;2--&gt;3--&gt;4
</span></span><span class="line"><span class="cl">          6--&gt;7--&gt;8
</span></span><span class="line"><span class="cl">  output: 1--&gt;2--&gt;3--&gt;4--&gt;6--&gt;7--&gt;8
</span></span></code></pre></div><ul>
<li>
<p>思路 - dummy node</p>
<p>通过使用哑节点来简化链表的操作</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">dummy node
</span></span><span class="line"><span class="cl">  <span class="o">[</span> <span class="o">][</span>*<span class="o">]</span>--&gt; <span class="o">[</span>1<span class="o">][</span>*<span class="o">]</span>--&gt; <span class="o">[</span>2<span class="o">][</span>*<span class="o">]</span>
</span></span><span class="line"><span class="cl">   ^
</span></span><span class="line"><span class="cl">   <span class="p">|</span>
</span></span><span class="line"><span class="cl">  <span class="o">[</span>*<span class="o">]</span>
</span></span><span class="line"><span class="cl">  head
</span></span></code></pre></div></li>
</ul>
<h2 id="栈">栈</h2>
<p>线性表：数组、链表</p>
<h3 id="模型">模型</h3>
<p>栈是操作受限的线性表，只能在线性表的同一端进行添加或删除元素，FIRST IN LAST OUT;</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">    <span class="p">|</span>_____<span class="p">|</span>栈顶<span class="o">(</span>只能在栈顶操作<span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">|</span>_____<span class="p">|</span>  
</span></span><span class="line"><span class="cl">    <span class="p">|</span>_____<span class="p">|</span>
</span></span><span class="line"><span class="cl">    <span class="p">|</span>_____<span class="p">|</span>
</span></span><span class="line"><span class="cl">    <span class="p">|</span>_____<span class="p">|</span>栈底
</span></span></code></pre></div><ul>
<li>
<p>Q：为什么需要栈这种数据结构</p>
<ul>
<li>安全</li>
<li>可读性强</li>
<li>和现实生活中的场景是对应的</li>
</ul>
</li>
</ul>
<h3 id="基本操作">基本操作</h3>
<ul>
<li>添加 push</li>
<li>删除 pop</li>
<li>查找(查看栈顶) peek</li>
<li>判空 empty  可用于遍历栈</li>
</ul>
<h3 id="实现">实现</h3>
<p>可以通过链表实现栈</p>
<p>Q：用单链表还是双向链表？</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">    <span class="o">[</span> <span class="o">][</span>*<span class="o">]</span>--&gt;<span class="o">[</span> <span class="o">][</span>*<span class="o">]</span>--&gt;<span class="o">[</span> <span class="o">][</span>*<span class="o">]</span>--&gt;<span class="o">[</span> <span class="o">][</span>*<span class="o">]</span>
</span></span><span class="line"><span class="cl">     ^                          
</span></span><span class="line"><span class="cl">     <span class="p">|</span>                          
</span></span><span class="line"><span class="cl">  top<span class="o">[</span>栈顶<span class="o">]</span>
</span></span></code></pre></div><p>单链表的栈顶的不能通过增删操作判定，需要从遍历看，单链表只能从表头开始遍历</p>
<h3 id="应用">应用</h3>
<p>栈一般应用在符合LIFO特性的场景</p>
<ul>
<li>
<p>函数调用栈</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">· call main<span class="o">()</span> 入栈
</span></span><span class="line"><span class="cl"><span class="p">|</span>
</span></span><span class="line"><span class="cl">---· call foo<span class="o">()</span> 入栈
</span></span><span class="line"><span class="cl">   <span class="p">|</span>
</span></span><span class="line"><span class="cl">   ·----· call bar<span class="o">()</span> 入栈
</span></span><span class="line"><span class="cl">        <span class="p">|</span>
</span></span><span class="line"><span class="cl">   ·----· <span class="k">return</span> bar<span class="o">()</span> 出栈
</span></span><span class="line"><span class="cl">   <span class="p">|</span>
</span></span><span class="line"><span class="cl">---·return foo<span class="o">()</span> 出栈
</span></span><span class="line"><span class="cl"><span class="p">|</span>
</span></span><span class="line"><span class="cl">·return main<span class="o">()</span> 出栈
</span></span></code></pre></div></li>
<li>
<p>符号匹配问题</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="p">{</span> <span class="p">[</span> <span class="p">(</span> <span class="p">)</span> <span class="p">]</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span>
</span></span></code></pre></div><p>遍历字符串</p>
<ol>
<li>遇到左括号，将对应的右括号入栈</li>
<li>遇到右括号，出栈，判断是否和遇到的符号相等</li>
<li>遍历完成后，若栈为空，返回true</li>
</ol>
</li>
<li>
<p>表示优先级</p>
<p>常使用<strong>单调栈</strong>表示优先级，例如表达式求值问题</p>
<ul>
<li>
<p>中缀表达式</p>
<p>人类视角下尝试用中缀表达式</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">a+b*c/d  <span class="o">=</span>&gt;  优先级
</span></span><span class="line"><span class="cl"><span class="m">1</span> + <span class="m">3</span> * <span class="m">4</span> / <span class="m">2</span>
</span></span></code></pre></div></li>
<li>
<p>后缀表达式</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="m">1</span> <span class="m">3</span> <span class="m">4</span> * <span class="m">2</span> / +
</span></span></code></pre></div><p>没有优先级，运算符出现的顺序，就是实际执行的顺序</p>
</li>
</ul>
<p>Q. 如何计算后缀表达式？</p>
<ul>
<li>遇到操作数
<ul>
<li>入栈</li>
</ul>
</li>
<li>遇到运算符
<ul>
<li>连续出栈两个操作数</li>
<li>计算</li>
<li>将结果入栈</li>
</ul>
</li>
</ul>
</li>
<li>
<p>用栈来记录轨迹</p>
<ul>
<li>
<p>浏览器的前进/后退功能</p>
<p>HTTP是无状态的协议，每一次请求都是独立的浏览器可以通过两个STACK来存放网页地址</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">            <span class="p">|</span>___<span class="p">|</span>
</span></span><span class="line"><span class="cl"><span class="p">|</span>___<span class="p">|</span>       <span class="p">|</span>___<span class="p">|</span>
</span></span><span class="line"><span class="cl"><span class="p">|</span>___<span class="p">|</span>       <span class="p">|</span>___<span class="p">|</span>
</span></span><span class="line"><span class="cl">  A           B
</span></span></code></pre></div><p>A存放访问页面，B存放关闭了的页面，当后退时，会将B的栈顶入栈到A</p>
</li>
<li>
<p>深度优先搜索</p>
</li>
<li>
<p>回溯算法</p>
</li>
</ul>
</li>
</ul>
<h2 id="队列">队列</h2>
<h3 id="模型-1">模型</h3>
<p>操作受限的线性表，一端添加元素，另一端删除元素，FIFO</p>
<pre tabindex="0"><code>         _______________
&lt;---出队  a1 a2 a3 ... an   &lt;--入队
         _______________
</code></pre><h3 id="基本操作-1">基本操作</h3>
<ul>
<li>入队 queue_push</li>
<li>出队 queue_pop</li>
<li>查看队头元素 queue_peek</li>
<li>判空 queue_empty</li>
<li>判满 queue_full</li>
</ul>
<h3 id="实现-1">实现</h3>
<p>可以通过动态数组实现队</p>
<ul>
<li>
<p>方案A, 用rear标识队尾</p>
<pre tabindex="0"><code> [A][B][C][D][E][F][G]
                    |
                    |
  0  1  2  3       rear
</code></pre><table>
<thead>
<tr>
<th>操作</th>
<th>时间复杂度/方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>入队</td>
<td>O(1)</td>
</tr>
<tr>
<td>出队</td>
<td>o(n)</td>
</tr>
<tr>
<td>peek</td>
<td>O(1)</td>
</tr>
<tr>
<td>判空</td>
<td>rear = 0</td>
</tr>
<tr>
<td>判满</td>
<td>rear = capacity</td>
</tr>
</tbody>
</table>
<p>缺点，出队复杂度过高</p>
</li>
<li>
<p>方案B，用front和rear标识队头队尾</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"> <span class="o">[</span>A<span class="o">][</span>B<span class="o">][</span>C<span class="o">][</span>D<span class="o">][</span>E<span class="o">][</span>F<span class="o">][</span>G<span class="o">]</span>
</span></span><span class="line"><span class="cl">  <span class="p">|</span>                 <span class="p">|</span>
</span></span><span class="line"><span class="cl">  <span class="p">|</span>                 <span class="p">|</span>
</span></span><span class="line"><span class="cl">front              rear
</span></span></code></pre></div><table>
<thead>
<tr>
<th>操作</th>
<th>时间复杂度/方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>入队</td>
<td>O(1)</td>
</tr>
<tr>
<td>出队</td>
<td>o(1)</td>
</tr>
<tr>
<td>peek</td>
<td>O(1)</td>
</tr>
<tr>
<td>判空</td>
<td>front - rear = 0</td>
</tr>
<tr>
<td>判满</td>
<td>rear - front = capacity</td>
</tr>
</tbody>
</table>
<p>两种判满方式的比较</p>
<table>
<thead>
<tr>
<th>方式</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>rear = capacity</td>
<td>浪费大量空间</td>
</tr>
<tr>
<td>rear - front = capacity</td>
<td>需要大量移动元素</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>方案C 采用循环数组</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">[</span> <span class="o">][</span> <span class="o">][</span> <span class="o">][</span>A<span class="o">][</span>B<span class="o">][</span>C<span class="o">][</span>D<span class="o">][</span>E<span class="o">][</span>F<span class="o">][</span>G<span class="o">]</span> capacity
</span></span><span class="line"><span class="cl"> <span class="p">|</span>        <span class="p">|</span>                       <span class="p">|</span>
</span></span><span class="line"><span class="cl"> <span class="p">|</span>        <span class="p">|</span>                       <span class="p">|</span>
</span></span><span class="line"><span class="cl">rear    front                    rear
</span></span></code></pre></div><p>当rear达到容量时，可以让其指向数组起点</p>
<pre tabindex="0"><code class="language-math" data-lang="math">rear+1 % capacity
</code></pre><ul>
<li>
<p>扩容：</p>
<ul>
<li>如果采用<strong>realloc扩容</strong>， 会破坏队列的逻辑结构</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">[</span>A<span class="o">][</span>B<span class="o">][</span>C<span class="o">][</span>D<span class="o">][</span> E <span class="o">][</span>F<span class="o">][</span>G<span class="o">]</span>
</span></span><span class="line"><span class="cl">             <span class="p">|</span> <span class="p">|</span>
</span></span><span class="line"><span class="cl">             <span class="p">|</span> <span class="p">|</span>
</span></span><span class="line"><span class="cl">             f r
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">[</span>A<span class="o">][</span>B<span class="o">][</span>C<span class="o">][</span>D<span class="o">][</span>E<span class="o">][</span>F<span class="o">][</span>G<span class="o">][</span> <span class="o">][</span> <span class="o">][</span> <span class="o">][</span> <span class="o">][</span> <span class="o">][</span> <span class="o">][</span> <span class="o">]</span>
</span></span><span class="line"><span class="cl">             <span class="p">|</span>        <span class="p">|</span>
</span></span><span class="line"><span class="cl">             <span class="p">|</span>        <span class="p">|</span>
</span></span><span class="line"><span class="cl">             f        r 
</span></span></code></pre></div><ul>
<li>使用<strong>malloc扩容</strong>，会重新申请一篇更大的空间，并将元素迁移到新的空间</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">step 1:队满
</span></span><span class="line"><span class="cl"><span class="o">[</span>A<span class="o">][</span>B<span class="o">][</span>C<span class="o">][</span>D<span class="o">][</span> E <span class="o">][</span>F<span class="o">][</span>G<span class="o">]</span>
</span></span><span class="line"><span class="cl">             <span class="p">|</span> <span class="p">|</span>
</span></span><span class="line"><span class="cl">             <span class="p">|</span> <span class="p">|</span>
</span></span><span class="line"><span class="cl">             f r
</span></span><span class="line"><span class="cl">step 2:扩容
</span></span><span class="line"><span class="cl"><span class="o">[</span>E<span class="o">][</span>F<span class="o">][</span>G<span class="o">][</span>A<span class="o">][</span>B<span class="o">][</span>C<span class="o">][</span>D<span class="o">][</span> <span class="o">][</span> <span class="o">][</span> <span class="o">][</span> <span class="o">][</span> <span class="o">][</span> <span class="o">][</span> <span class="o">]</span>
</span></span><span class="line"><span class="cl"> <span class="p">|</span>                    <span class="p">|</span>
</span></span><span class="line"><span class="cl"> <span class="p">|</span>                    <span class="p">|</span>
</span></span><span class="line"><span class="cl"> f                    r
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> step 3:
</span></span><span class="line"><span class="cl"> 清除旧数组的内从空间
</span></span></code></pre></div></li>
<li>
<p>入队：注意使用扩容策略</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">if</span><span class="p">(</span><span class="err">需要扩容</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="nf">grow_capacity</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">elemnts</span><span class="p">[</span><span class="n">rear</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">rear</span> <span class="o">=</span> <span class="p">(</span><span class="n">rear</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">capcaity</span><span class="p">;</span>
</span></span></code></pre></div></li>
<li>
<p>出队</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">front</span> <span class="o">=</span> <span class="p">(</span><span class="n">front</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">capacity</span>
</span></span></code></pre></div></li>
<li>
<p>查看队头</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">elements</span><span class="p">[</span><span class="n">front</span><span class="p">]</span>
</span></span></code></pre></div></li>
<li>
<p>判空</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">rear</span> <span class="o">=</span> <span class="n">front</span><span class="p">;</span> 
</span></span></code></pre></div></li>
<li>
<p>判满</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">type</span> <span class="mi">1</span><span class="o">:</span><span class="err">队满</span>
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="n">A</span><span class="p">][</span><span class="n">B</span><span class="p">][</span><span class="n">C</span><span class="p">][</span><span class="n">D</span><span class="p">][</span> <span class="n">E</span> <span class="p">][</span><span class="n">F</span><span class="p">][</span><span class="n">G</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">             <span class="o">^</span> <span class="o">^</span>
</span></span><span class="line"><span class="cl">             <span class="o">|</span> <span class="o">|</span>
</span></span><span class="line"><span class="cl">             <span class="n">f</span> <span class="n">r</span>
</span></span><span class="line"><span class="cl"><span class="err">此时队满条件</span>
</span></span><span class="line"><span class="cl"><span class="n">rear</span> <span class="o">=</span> <span class="n">front</span>
</span></span><span class="line"><span class="cl"><span class="err">与队空条件重叠</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">解决方法</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="err">添加</span><span class="n">size</span> <span class="err">属性</span><span class="p">,</span><span class="err">队满条件</span> 
</span></span><span class="line"><span class="cl"><span class="n">rear</span> <span class="o">==</span> <span class="n">front</span> <span class="o">&amp;&amp;</span> <span class="n">size</span> <span class="o">==</span> <span class="n">capacity</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">解决方法</span><span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="err">空出一个位置</span><span class="p">,</span><span class="err">队满条件</span> 
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="n">A</span><span class="p">][</span><span class="n">B</span><span class="p">][</span><span class="n">C</span><span class="p">][</span><span class="n">D</span><span class="p">][</span> <span class="p">][</span><span class="n">F</span><span class="p">][</span><span class="n">G</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">          <span class="o">^</span>     <span class="o">^</span>
</span></span><span class="line"><span class="cl">          <span class="o">|</span>     <span class="o">|</span>
</span></span><span class="line"><span class="cl">          <span class="n">r</span>     <span class="n">f</span>
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p>结构体</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">//Queue.h
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define MAX_CAPACITY
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">typedef</span> <span class="kt">int</span> <span class="n">E</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">E</span><span class="o">*</span> <span class="n">elements</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">front</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">rear</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">capacity</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span><span class="n">Queue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">__________</span>
</span></span><span class="line"><span class="cl"><span class="o">|*</span><span class="n">elements</span><span class="o">|</span>   <span class="o">----&gt;</span>  <span class="p">[</span> <span class="p">][</span> <span class="p">][</span> <span class="p">][</span> <span class="p">]</span>
</span></span></code></pre></div></li>
</ul>
<h3 id="应用-1">应用</h3>
<ul>
<li>
<p>缓冲（FIFO, 具有公平性）</p>
<p>例如电商平台的促销活动，订单放入缓冲区（队列），采用有界队列可以防止OOM（Out Of Memory, 会杀死进程）</p>
</li>
<li>
<p>消息队列</p>
<p>中间件的一种，处理单点故障</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">      <span class="o">[</span>单点故障<span class="o">]</span>---<span class="o">[</span>B<span class="o">]</span>
</span></span><span class="line"><span class="cl">        <span class="p">|</span>    /   <span class="p">|</span>
</span></span><span class="line"><span class="cl">       <span class="o">[</span>A<span class="o">]</span>------<span class="o">[</span>C<span class="o">]</span>   
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   一个集群耦合，会导致故障扩散 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">       <span class="o">[</span>单点故障<span class="o">]</span>------<span class="o">[</span>B<span class="o">]</span>
</span></span><span class="line"><span class="cl">        <span class="p">|</span> <span class="se">\ </span>         / <span class="p">|</span>
</span></span><span class="line"><span class="cl">        <span class="p">|</span>   <span class="o">[</span>消息队列<span class="o">]</span>  <span class="p">|</span>
</span></span><span class="line"><span class="cl">        <span class="p">|</span> /          <span class="se">\ </span><span class="p">|</span>
</span></span><span class="line"><span class="cl">       <span class="o">[</span>A<span class="o">]</span>------------<span class="o">[</span>C<span class="o">]</span>
</span></span></code></pre></div></li>
<li>
<p>广度优先搜索DFS</p>
<p>社交平台三度好友，人脉圈</p>
</li>
</ul>
<h2 id="哈希表-">哈希表 ⭐</h2>
<p>QA：为什么需要哈希表？</p>
<ul>
<li>
<p>扩展- Key-Value <strong>键值对数据</strong></p>
<table>
<thead>
<tr>
<th>键</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>单词</td>
<td>释义</td>
</tr>
<tr>
<td>账号</td>
<td>账号信息</td>
</tr>
<tr>
<td>关键字</td>
<td>一串相关网页</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>统计一个文件中，字母出现的次数(不区分大小写)</p>
<table>
<thead>
<tr>
<th>值</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>···</th>
<th>Z</th>
</tr>
</thead>
<tbody>
<tr>
<td>键</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>···</td>
<td>25</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>用数组表示键值对数据 ，有如下限制</p>
<ul>
<li>键的取值范围很小</li>
<li>键可以很容易的转化成数组的下标</li>
</ul>
</li>
<li>
<p>如果不满足上述的限制条件，推荐使用hash table</p>
</li>
</ul>
<h3 id="模型-2">模型</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                             ┌────────hash桶-<span class="o">[]</span>
</span></span><span class="line"><span class="cl">                             <span class="p">|</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>Key的取值范围<span class="o">]</span>---取出key---&gt;hash函数────hash桶-<span class="o">[]</span>-<span class="o">[]</span>
</span></span><span class="line"><span class="cl">                             <span class="p">|</span>
</span></span><span class="line"><span class="cl">                             └────────hash桶<span class="o">(</span>容器<span class="o">)</span>
</span></span></code></pre></div><p>注意</p>
<ul>
<li>
<p>hash桶可以看作是一个容器</p>
</li>
<li>
<p><strong>同一个hash表，hash桶的数据结构可以不一样</strong></p>
</li>
</ul>
<h3 id="基本操作-2">基本操作</h3>
<ul>
<li>
<p>增</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="nf">put</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="n">val</span><span class="p">)</span>
</span></span></code></pre></div><ul>
<li>key的值是唯一的</li>
</ul>
</li>
<li>
<p>删</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="nf">delete</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</span></span></code></pre></div></li>
<li>
<p>查</p>
<pre tabindex="0"><code>val = get(key)
</code></pre></li>
<li>
<p>遍历</p>
<p>依次遍历每一个hash桶</p>
</li>
</ul>
<h3 id="实现-2">实现</h3>
<h4 id="哈希函数数据的指纹">哈希函数（数据的指纹）</h4>
<p>如果哈希函数的新能足够好，就可以将其当作数据的指纹</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">checksam:
</span></span><span class="line"><span class="cl">     256bit
</span></span><span class="line"><span class="cl">      <span class="o">[</span> <span class="o">]</span>─────────────────&gt;<span class="o">[</span> <span class="o">]</span>
</span></span><span class="line"><span class="cl">       A              	    B
</span></span><span class="line"><span class="cl">md5──&gt;md5码<span class="o">(</span>256b<span class="o">)</span>    md5──&gt;md5码<span class="o">(</span>256b<span class="o">)</span>
</span></span><span class="line"><span class="cl">       <span class="p">|</span>                    <span class="p">|</span>
</span></span><span class="line"><span class="cl">      指纹                验证指纹
</span></span></code></pre></div><p>Q 什么是好的哈希函数?</p>
<ul>
<li>
<p>计算速度要快</p>
</li>
<li>
<p>要求hash值<strong>平均分布</strong></p>
<p>注意：以下三点是为了满足安全性：</p>
</li>
<li>
<p>hash碰撞的概率低</p>
</li>
<li>
<p>要对数据非常敏感</p>
<p>相似的数据，生成的哈希值应该完全不同</p>
</li>
<li>
<p>逆向要非常困难</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">hash值 ---&gt; data
</span></span></code></pre></div><p>要让通过hash值找出原数据几乎不可能实现</p>
</li>
</ul>
<p>完美的hash函数是在模拟等概率随机映射</p>
<p>只能通过模拟，不能实际应用，用有规律的算法模拟离散的数据</p>
<h4 id="哈希桶解决哈希冲突">哈希桶（解决哈希冲突）</h4>
<p>解决哈希冲突的两种方法</p>
<ul>
<li>
<p>拉链法</p>
<p>本质上是用链表来做哈希桶，例如C++的unordered_map，Java的HashMap</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">[</span> <span class="o">][</span>*<span class="o">][</span> <span class="o">][</span> <span class="o">][</span> <span class="o">]</span>
</span></span><span class="line"><span class="cl">    <span class="p">|</span>
</span></span><span class="line"><span class="cl">  <span class="o">[</span>key<span class="o">]</span>
</span></span><span class="line"><span class="cl">  <span class="o">[</span>val<span class="o">]</span>
</span></span><span class="line"><span class="cl">   <span class="o">[</span>*<span class="o">]</span>
</span></span><span class="line"><span class="cl">    <span class="p">|</span>
</span></span><span class="line"><span class="cl">  <span class="o">[</span>key<span class="o">]</span>
</span></span><span class="line"><span class="cl">  <span class="o">[</span>val<span class="o">]</span>
</span></span><span class="line"><span class="cl">   <span class="o">[</span>*<span class="o">]</span>
</span></span></code></pre></div></li>
<li>
<p>开放地址法</p>
<p>探测后面的空余地址，将发生碰撞的元素存入其中</p>
<ul>
<li>
<p>线性探测</p>
<p>每次探测只+1</p>
</li>
<li>
<p>平方探测</p>
<p>每次探测的幅度不一样</p>
</li>
<li>
<p>再散列法</p>
<p>从has1 hash2等不同的哈希函数中找新的hash函数定位</p>
</li>
</ul>
<p><strong>哈希桶</strong>，开放地址法的哈希桶是一种逻辑结构，只要映射的位置相同，就属于同一个哈希桶</p>
</li>
</ul>
<p>实现过程</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">//size 是key-val键值对的个数
</span></span><span class="line"><span class="cl">//hashseed 用于保证安全性
</span></span><span class="line"><span class="cl">   
</span></span><span class="line"><span class="cl">   table<span class="o">[</span>*<span class="o">]</span>------&gt;<span class="o">[</span>*<span class="o">][</span>*<span class="o">][</span>*<span class="o">][</span>*<span class="o">][</span>*<span class="o">][</span>*<span class="o">][</span>*<span class="o">][</span>*<span class="o">]</span>
</span></span><span class="line"><span class="cl">    size<span class="o">[</span> <span class="o">]</span>           <span class="p">|</span>
</span></span><span class="line"><span class="cl">capacity<span class="o">[</span> <span class="o">]</span>         <span class="o">[</span>key<span class="o">]</span>
</span></span><span class="line"><span class="cl">hashseed<span class="o">[</span> <span class="o">]</span>         <span class="o">[</span>val<span class="o">]</span>
</span></span><span class="line"><span class="cl">                     <span class="o">[</span>*<span class="o">]</span>
</span></span><span class="line"><span class="cl">                      <span class="p">|</span>
</span></span><span class="line"><span class="cl">                    <span class="o">[</span>key<span class="o">]</span>
</span></span><span class="line"><span class="cl">                    <span class="o">[</span>val<span class="o">]</span>
</span></span><span class="line"><span class="cl">                     <span class="o">[</span>*<span class="o">]</span>
</span></span></code></pre></div><p>API</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">//Hashmap.c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">**</span> <span class="n">table</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">capacity</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint32_t</span> <span class="n">hashseed</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span><span class="n">HashMap</span><span class="p">;</span>
</span></span></code></pre></div><p>测试单元</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#icnlude&lt;stdio.h&gt;
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span><span class="cpf">&#34;Hashmap.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//1.创建空的哈希表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">HashMap</span><span class="o">*</span> <span class="n">map</span> <span class="o">=</span> <span class="nf">hashmap_create</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nf">hashmap_put</span><span class="p">(</span><span class="n">map</span><span class="p">,</span><span class="s">&#34;liuqiangdong&#34;</span><span class="p">,</span><span class="s">&#34;zhangzetian&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">hashmap_put</span><span class="p">(</span><span class="n">map</span><span class="p">,</span><span class="s">&#34;wangbaoqiang&#34;</span><span class="p">,</span><span class="s">&#34;marong&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">hashmap_put</span><span class="p">(</span><span class="n">map</span><span class="p">,</span><span class="s">&#34;wenzhang&#34;</span><span class="p">,</span><span class="s">&#34;mayiliang&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">hashmap_put</span><span class="p">(</span><span class="n">map</span><span class="p">,</span><span class="s">&#34;jianailiang&#34;</span><span class="p">,</span><span class="s">&#34;lixaolu&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>函数实现</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span><span class="cpf">&lt;hashmap.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span><span class="cpf">&lt;time.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define DEDAULT_CAPACITY
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">typedef</span> <span class="kt">char</span><span class="o">*</span> <span class="n">V</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">HashMap</span><span class="o">*</span> <span class="nf">hasmap_create</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">HashMap</span><span class="o">*</span> <span class="n">map</span> <span class="o">=</span> <span class="nf">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">HashMap</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">map</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//错误处理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//NULL用calloc
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">map</span><span class="o">-&gt;</span><span class="n">table</span> <span class="o">=</span> <span class="nf">calloc</span><span class="p">(</span><span class="n">DEFAULT_CAPACITY</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">	<span class="n">map</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">map</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">=</span> <span class="n">DEFAULT_CAPACITY</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">map</span><span class="o">-&gt;</span><span class="n">hashseed</span> <span class="o">=</span> <span class="nf">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">map</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 如果key不存在，添加key-val,并返回null
</span></span></span><span class="line"><span class="cl"><span class="c1">// 如果key存在，更新key关联的val，并返回原来的val
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">V</span> <span class="nf">hashmap_put</span><span class="p">(</span><span class="n">HashMap</span><span class="o">*</span> <span class="n">map</span><span class="p">,</span> <span class="n">K</span> <span class="n">key</span><span class="p">,</span> <span class="n">V</span> <span class="n">val</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="nf">hash</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="nf">strlen</span><span class="p">(</span><span class="n">key</span><span class="p">),</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">hashseed</span><span class="p">)</span><span class="o">%</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">;</span>  <span class="c1">//求得索引(hash桶)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//遍历链表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Node</span><span class="o">*</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span> <span class="c1">//table中的第一个元素是链表的地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="n">curr</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="nf">strcmp</span><span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//更新Key关联的值，并返回原来的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">V</span> <span class="n">oldval</span> <span class="n">val</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">curr</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">oldval</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span><span class="c1">// curr == NULL
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//添加Key-val,并返回null;用头插法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Node</span><span class="o">*</span> <span class="n">newnode</span> <span class="o">=</span> <span class="nf">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Node</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">newnode</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">newnode</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">newnode</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//链接过程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">map</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">newnode</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//更新hash表的信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">map</span><span class="o">-&gt;</span><span class="n">size</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//根据Key，获取关联值，如果Key不存在，返回NULL
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">V</span> <span class="nf">hashmap_get</span><span class="p">(</span><span class="n">HashMap</span><span class="o">*</span> <span class="n">map</span><span class="p">,</span> <span class="n">K</span> <span class="n">key</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  	<span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="nf">hash</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="nf">strlen</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">hashseed</span><span class="p">)</span> <span class="o">%</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">*</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">curr</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="nf">strcmp</span><span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//删除键值对，如果Key不存在，什么也不做
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">hashmap_delete</span><span class="p">(</span><span class="n">HashMap</span><span class="o">*</span> <span class="n">map</span><span class="p">,</span> <span class="n">K</span> <span class="n">key</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="nf">hash</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="nf">strlen</span><span class="p">(</span><span class="n">key</span><span class="p">),</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">hashseed</span><span class="p">)</span><span class="o">%</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">*</span> <span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">*</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">curr</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="nf">strcmp</span><span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// todo: 删除curr节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            	<span class="k">if</span><span class="p">(</span><span class="n">prev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                    <span class="n">map</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            	<span class="nf">free</span><span class="p">(</span><span class="n">curr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            	<span class="n">map</span><span class="o">-&gt;</span><span class="n">size</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            	<span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">prev</span> <span class="o">=</span> <span class="n">curr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//销毁hash表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">hashmap_destroy</span><span class="p">(</span><span class="n">HashMap</span><span class="o">*</span> <span class="n">map</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">Node</span><span class="o">*</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span><span class="p">(</span><span class="n">curr</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">Node</span><span class="o">*</span> <span class="n">next</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="nf">free</span><span class="p">(</span><span class="n">curr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">curr</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//释放动态数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">free</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">free</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span></code></pre></div><ul>
<li>哈希表的扩容
<ol>
<li>安全性(hashseed）</li>
<li>用calloc申请新的更大的动态数组</li>
<li>rehash，将所有的节点挂载到新数组中</li>
<li>释放原数组</li>
</ol>
</li>
</ul>
<h4 id="性能">性能</h4>
<table>
<thead>
<tr>
<th style="text-align:center">操作</th>
<th style="text-align:center">时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">get</td>
<td style="text-align:center">O(L)</td>
</tr>
<tr>
<td style="text-align:center">put</td>
<td style="text-align:center">O(L)</td>
</tr>
<tr>
<td style="text-align:center">delete</td>
<td style="text-align:center">O(L)</td>
</tr>
</tbody>
</table>
<p>L表示链表的平均长度</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nv">L</span> <span class="o">=</span> size/capacity
</span></span><span class="line"><span class="cl">要保证L不超过一个一个常 数<span class="o">(</span>L&lt;<span class="o">=</span>1或L&lt;<span class="o">=</span>0.75<span class="o">)</span>
</span></span><span class="line"><span class="cl">                   <span class="p">|</span>
</span></span><span class="line"><span class="cl">              load factor
</span></span><span class="line"><span class="cl">                负载因子
</span></span></code></pre></div><p>哈希表的本质是用空间换时间</p>
<h3 id="应用-2">应用</h3>
<ul>
<li>
<p>存储键值对数据</p>
</li>
<li>
<p>Redis,内存数据库（键值对数据库），Redis底层大量使用了Hash表</p>
</li>
</ul>
<h2 id="位图">位图</h2>
<h3 id="模型-3">模型</h3>
<p>位图的实质是位的数组</p>
<p>Q：为什么需要构建一个专门的数据结构表示位的数组</p>
<p>原因：计算机的最小寻址单位是字节，而不是位</p>
<h3 id="基本操作-3">基本操作</h3>
<ul>
<li>
<p>增</p>
<p>set, 将某一位设置为1</p>
</li>
<li>
<p>删</p>
<p>unset, 将某一位设为0</p>
</li>
<li>
<p>查</p>
<p>isset, 判断某一位是不是1</p>
</li>
<li>
<p>遍历</p>
</li>
</ul>
<h3 id="实现-3">实现</h3>
<p>位图是一种内存紧凑的数据结构</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"> BitMap
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">array<span class="o">[</span>*<span class="o">]</span>----&gt;<span class="o">[][][][][][]</span>
</span></span><span class="line"><span class="cl"> bits<span class="o">[</span> <span class="o">]</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">//bitmap.h
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span><span class="cpf">&lt;stdint.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint32_t</span><span class="o">*</span> <span class="n">array</span><span class="p">;</span>  <span class="c1">//动态数组，放在堆上，大小要确定（32bits）,2.无符号整数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">size_t</span> <span class="n">btis</span><span class="p">;</span>  <span class="c1">//位图的长度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="n">BitMap</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//API
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">BitMap</span><span class="o">*</span> <span class="nf">bitmap_create</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">bits</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">bitmap_destroy</span><span class="p">(</span><span class="n">BitMap</span><span class="o">*</span> <span class="n">bm</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">bitmap_set</span><span class="p">(</span><span class="n">BitMap</span><span class="o">*</span> <span class="n">bm</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">bitmap_unset</span><span class="p">(</span><span class="n">BitMap</span><span class="o">*</span> <span class="n">bm</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">bitmap_isset</span><span class="p">(</span><span class="n">BitMap</span><span class="o">*</span> <span class="n">bm</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">bitmap_clear</span><span class="p">(</span><span class="n">BitMap</span><span class="o">*</span> <span class="n">bm</span><span class="p">);</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">//bitmap.c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span><span class="cpf">&lt;bitmap.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#define BITS_PER_WORD 32
</span></span></span><span class="line"><span class="cl"><span class="cp">#define BITMAP_SHIFT 5
</span></span></span><span class="line"><span class="cl"><span class="cp">#define BITMAP_MASK 0X1F
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 存储bits,需要word的长度，因为空间申请是按字申请
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define BITMAP_SIZE(bits) ((bits + BITS_PER_WORD -1) &gt;&gt; BITMAP_SHIFT)  </span><span class="c1">//要向上取整
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// bits: 位图的长度
</span></span></span><span class="line"><span class="cl"><span class="c1">// bits = 100
</span></span></span><span class="line"><span class="cl"><span class="c1">// 100 / 32 + 1  = (100 + 32 -1) / 32
</span></span></span><span class="line"><span class="cl"><span class="c1">// 1 + (32 - 1) / 32
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">BitMap</span><span class="o">*</span> <span class="nf">bitmap_create</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">bits</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">BitMap</span><span class="o">*</span> <span class="n">bm</span> <span class="o">=</span> <span class="nf">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">BitMap</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">bm</span><span class="o">-&gt;</span><span class="n">array</span> <span class="o">=</span> <span class="nf">calloc</span><span class="p">(</span><span class="nf">BITMAP_SIZE</span><span class="p">(</span><span class="n">bits</span><span class="p">)</span> <span class="p">,</span><span class="n">BITS_PER_WORD</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">//乘除2的幂，考虑位运算
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">bm</span><span class="o">-&gt;</span><span class="n">bits</span> <span class="o">=</span> <span class="n">bits</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">bm</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//扩充位图，能够存下Bits位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">grow_capacity</span><span class="p">(</span><span class="n">BitMap</span><span class="o">*</span> <span class="n">bm</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">bits</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//位图：内存紧凑的数据结构，应尽可能少的减少扩充空间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//扩容策略，需要多大，就申请多大的内存空间,可以考虑使用relloc函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">uint32_t</span><span class="o">*</span> <span class="n">new_array</span> <span class="o">=</span> <span class="nf">realloc</span><span class="p">(</span><span class="n">bm</span><span class="o">-&gt;</span><span class="n">array</span><span class="p">,</span> <span class="nf">BITMAP_SIZE</span><span class="p">(</span><span class="n">bits</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">BITS_PER_WORD</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">new_array</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Error:failed to allocate in new_array&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">bm</span><span class="o">-&gt;</span><span class="n">array</span> <span class="o">=</span> <span class="n">new_array</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//将扩充的部分置为0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">bytes</span> <span class="o">=</span> <span class="p">(</span><span class="nf">BITMAP_SIZE</span><span class="p">(</span><span class="n">bits</span><span class="p">)</span> <span class="o">-</span> <span class="nf">BITMAP_SIZE</span><span class="p">(</span><span class="n">bm</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="n">BITS_PER_WORD</span><span class="o">&gt;&gt;</span><span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">memset</span><span class="p">(</span><span class="n">bm</span><span class="o">-&gt;</span><span class="n">array</span> <span class="o">+</span> <span class="nf">BITMAP_SIZE</span><span class="p">(</span><span class="n">bm</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">),</span><span class="mi">0</span><span class="p">,</span><span class="n">bytes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//设置索引为n的位
</span></span></span><span class="line"><span class="cl"><span class="c1">//100, 32 * 4 = 128 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">bitmap_set</span><span class="p">(</span><span class="n">BitMap</span><span class="o">*</span> <span class="n">bm</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span> <span class="o">&gt;</span> <span class="n">bm</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">){</span>    
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="nf">BITMAP_SIZE</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nf">BITMAP_SIZE</span><span class="p">(</span><span class="n">bm</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//扩容
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        	<span class="nf">grow_capacity</span><span class="p">(</span><span class="n">bm</span><span class="p">,</span><span class="n">bits</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    	<span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">bm</span><span class="o">-&gt;</span><span class="n">bits</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//容量足够，直接设置第n位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//如何表示第n位(word, offset) 在哪个字，偏移值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">size_t</span> <span class="n">word</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">BITMAP_SHIFT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">size_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">32</span><span class="p">;</span>  <span class="c1">//等价于 n &amp; 0x1F  11011 00 10000
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">bm</span><span class="o">-&gt;</span><span class="n">array</span><span class="p">[</span><span class="n">word</span><span class="p">]</span> <span class="o">|=</span> <span class="p">(</span><span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="n">offset</span><span class="p">);</span>  <span class="c1">// 与其进行0001 000或运算
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">                                  
</span></span><span class="line"><span class="cl">                                  
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">bitmap_unset</span><span class="p">(</span><span class="n">BitMap</span><span class="o">*</span> <span class="n">bm</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//找到第n位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">size_t</span> <span class="n">word</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">BITMAP_SHIFT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">size_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&amp;</span> <span class="n">BITMAP_MASK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">bm</span><span class="o">-&gt;</span><span class="n">array</span><span class="p">[</span><span class="n">word</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="n">offset</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">                                  
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">bitmap_isset</span><span class="p">(</span><span class="n">BitMap</span><span class="o">*</span> <span class="n">bm</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//找到第n位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="n">bm</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//找到第n位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">size_t</span> <span class="n">word</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">BITMAP_SHIFT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">size_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&amp;</span> <span class="n">BITMAP_MASK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">bm</span><span class="o">-&gt;</span><span class="n">array</span><span class="p">[</span><span class="n">word</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="n">offset</span><span class="p">);</span> <span class="cm">/*000001000*/</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">                                  
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">bitmap_clear</span><span class="p">(</span><span class="n">BitMap</span><span class="o">*</span> <span class="n">bm</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">size_t</span> <span class="n">bytes</span> <span class="o">=</span> <span class="nf">BITMAP_SIZE</span><span class="p">(</span><span class="n">bm</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">)</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Word</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">memset</span><span class="p">(</span><span class="n">bm</span><span class="o">-&gt;</span><span class="n">array</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>关于memoryset</p>
<p>一个字节一个字节地设置</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">                                              <span class="err">长度</span>    
</span></span><span class="line"><span class="cl"><span class="nf">memset</span><span class="p">(</span><span class="n">bm</span><span class="o">-&gt;</span><span class="n">array</span> <span class="o">+</span> <span class="nf">BITMAP_SIZE</span><span class="p">(</span><span class="n">bm</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                     <span class="err">起始地址</span>              <span class="o">|</span>  
</span></span><span class="line"><span class="cl">                                     <span class="err">每一个字节的值（</span><span class="mi">0</span><span class="o">~</span><span class="mh">0xFF</span><span class="err">）</span>
</span></span></code></pre></div><p>总结</p>
<table>
<thead>
<tr>
<th style="text-align:center">操作</th>
<th style="text-align:center">位操作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">n * 32</td>
<td style="text-align:center">n&laquo;5</td>
</tr>
<tr>
<td style="text-align:center">n / 32</td>
<td style="text-align:center">n&raquo;5</td>
</tr>
<tr>
<td style="text-align:center">n % 32</td>
<td style="text-align:center">n&amp;0x1F</td>
</tr>
</tbody>
</table>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">//测设单元 main.c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&#34;BitMap.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">BitMap</span><span class="o">*</span> <span class="n">bm</span> <span class="o">=</span> <span class="nf">bitmap_create</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">bitmap_set</span><span class="p">(</span><span class="n">bm</span><span class="p">,</span> <span class="mi">9</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">bitmap_set</span><span class="p">(</span><span class="n">bm</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>    
</span></span><span class="line"><span class="cl">    <span class="nf">bitmap_set</span><span class="p">(</span><span class="n">bm</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">bitmap_set</span><span class="p">(</span><span class="n">bm</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="nf">bitmap_set</span><span class="p">(</span><span class="n">bm</span><span class="p">,</span> <span class="mi">128</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="应用-3">应用</h3>
<ul>
<li>
<p>面试题：存储10亿个qq用户每个人的在线状态，是或否</p>
<ul>
<li>
<p>如果用int数组存的话，过于消耗存储空间，需要4GB;</p>
</li>
<li>
<p>如果用位图存储的话，只需要250MB;</p>
</li>
</ul>
</li>
<li>
<p>排序并去重</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">[</span>128<span class="o">][</span>7<span class="o">][</span>468<span class="o">][</span>···<span class="o">]</span>
</span></span></code></pre></div><ul>
<li>采用排序算法
<ul>
<li>排序O(n*logn)</li>
<li>去重O(n)</li>
</ul>
</li>
<li>位图
<ul>
<li>将数值当作下标，设置其在位图中的值为1</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="二叉树">二叉树</h2>
<ul>
<li>
<p>定义：每一个结点的度都&lt;=2</p>
</li>
<li>
<p>二叉树的两种特殊形态：</p>
<ul>
<li>完全二叉树：除了第h层外，其它各层节点都达到最大值，且第h层的节点都连续排在最左边</li>
<li>满二叉树：每一层的节点数目都达到最大值</li>
</ul>
<p>满二叉树一定是一个完全二叉树</p>
</li>
</ul>
<h3 id="二叉搜索树">二叉搜索树</h3>
<p>BST(Binary Search Tree)：在二叉树的基础上加了限制条件，使得树中的节点可以按照某种规则进行比较</p>
<ul>
<li>左子树中的所有节点的key值都比根节点小，并且左子树也是二叉搜索树</li>
<li>右子树中所有的key值都比根节点的key值大，并且右子树也是二叉搜索树</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">         BST    <span class="o">[</span>*<span class="o">]</span>
</span></span><span class="line"><span class="cl">                 <span class="p">|</span>            
</span></span><span class="line"><span class="cl">            <span class="o">[</span>*<span class="o">][</span>key<span class="o">][</span>*<span class="o">]</span>
</span></span><span class="line"><span class="cl">            /          <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>       <span class="o">[</span>*<span class="o">][</span>key<span class="o">][</span>*<span class="o">]</span>  <span class="o">[</span>*<span class="o">][</span>key<span class="o">][</span>*<span class="o">]</span>   
</span></span></code></pre></div><h3 id="实现-4">实现</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="kt">int</span> <span class="n">K</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">tree_node</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">K</span> <span class="n">key</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">tree_node</span><span class="o">*</span> <span class="n">left</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">tree_node</span><span class="o">*</span> <span class="n">right</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span><span class="n">TreeNode</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//typedef TreeNode* BST; 给指针定义别名的方法，灵活性过差，不易扩展其它信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span><span class="n">BST</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//API
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">//创建一棵空树
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">BST</span><span class="o">*</span> <span class="nf">bst_create</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">calloc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">BST</span><span class="p">));</span> <span class="c1">//使用了Calloc返回NULL值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//如果key存在，什么也不做,查找路径类似单链表，插入用尾插法
</span></span></span><span class="line"><span class="cl"><span class="c1">//如果Key不存在，则添加Key
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">BST</span><span class="o">*</span> <span class="nf">bst_insert</span><span class="p">(</span><span class="n">BST</span><span class="o">*</span> <span class="n">tree</span><span class="p">,</span><span class="n">K</span> <span class="n">key</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">tree</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">cmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">curr</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">cmp</span> <span class="o">=</span> <span class="n">key</span> <span class="o">-</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">key</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">cmp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">parent</span> <span class="o">=</span> <span class="n">curr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">cmp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">parent</span> <span class="o">=</span> <span class="n">curr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//相等的情况，说明已经存在，直接返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span><span class="c1">//curr == NULL
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//插入节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="nf">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">TreeNode</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">node</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//链接到树中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">parent</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">tree</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">cmp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">parent</span><span class="o">-&gt;</span><span class="n">left</span>  <span class="o">=</span> <span class="n">key</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">cmp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">parent</span><span class="o">-&gt;</span><span class="n">left</span>  <span class="o">=</span> <span class="n">key</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">BST</span><span class="o">*</span> <span class="nf">bst_search</span><span class="p">(</span><span class="n">BST</span><span class="o">*</span> <span class="n">tree</span><span class="p">,</span><span class="n">K</span> <span class="n">key</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">tree</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">curr</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">cmp</span> <span class="o">=</span> <span class="n">key</span> <span class="o">-</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">cmp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">cmp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">curr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span><span class="c1">//curr == NULL的情况
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//中序遍历内部细节
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">inorder</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//a.边界条件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//b.递归公式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//遍历左子树
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">inorder</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//遍历根节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d &#34;</span><span class="p">,</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//遍历右子树
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">inorder</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//中序遍历对外的API
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">bst_inorder</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">tree</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//委托给inorder，外包
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">inorder</span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//层次遍历
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">bst_levelorder</span><span class="p">(</span><span class="n">BST</span><span class="o">*</span> <span class="n">tree</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//1.创建队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Queue</span><span class="o">*</span> <span class="n">q</span> <span class="o">=</span> <span class="nf">queue_create</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//2.将根节点入队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">queue_push</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">tree</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//3.循环遍历
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="n">queue_empty</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//出队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">TreeNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="nf">queue_pop</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//遍历该节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d &#34;</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//判断该节点是否有左孩子
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="nf">queue_push</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="nf">queue_push</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span><span class="c1">// queue_empty(q) == true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">BST</span><span class="o">*</span> <span class="nf">bst_delete</span><span class="p">(</span><span class="n">BST</span><span class="o">*</span> <span class="n">tree</span><span class="p">,</span><span class="n">K</span> <span class="n">key</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//1.查找要删除的节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">tree</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">curr</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">cmp</span> <span class="o">=</span> <span class="n">key</span> <span class="o">-</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">cmp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        	<span class="n">parent</span> <span class="o">=</span> <span class="n">curr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">cmp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">parent</span> <span class="o">=</span> <span class="n">curr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//TODO:删除curr节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">//代码缩进的层次越高，代码的复杂度越高
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span><span class="c1">//curr == NULL，不用进行任何操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">curr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//退化成degree == 0 || degree == 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">TreeNode</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">curr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">TreeNode</span><span class="o">*</span> <span class="n">min</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span><span class="p">(</span><span class="n">min</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">p</span> <span class="o">=</span> <span class="n">min</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">min</span> <span class="o">=</span> <span class="n">min</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span><span class="c1">//min-&gt;left == NULL;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        
</span></span><span class="line"><span class="cl">		<span class="n">curr</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="n">min</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">parent</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">curr</span> <span class="o">=</span> <span class="n">min</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 统一处理（degree == 0 || degree == 1）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 删除curr节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">child</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">&gt;</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">?</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="nl">left</span> <span class="p">:</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>  <span class="c1">//找到唯一的孩子
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">parent</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">tree</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">=</span> <span class="n">child</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">cmp</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">-</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">cmp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">parent</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">child</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">cmp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">parent</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">child</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">parent</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">child</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nf">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">BST</span><span class="o">*</span> <span class="nf">bst_destroy</span><span class="p">(</span><span class="n">BST</span><span class="o">*</span> <span class="n">tree</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//测试单元
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">   <span class="n">BST</span><span class="o">*</span> <span class="n">tree</span> <span class="o">=</span> <span class="nf">best_create</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">   <span class="n">bst_insert</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>
<p>二叉树的遍历</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">      <span class="o">[</span> <span class="m">9</span> <span class="o">]</span>
</span></span><span class="line"><span class="cl">      /   <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    <span class="o">[</span>5<span class="o">]</span>   <span class="o">[</span>42<span class="o">]</span>
</span></span><span class="line"><span class="cl">    /      /  <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  <span class="o">[</span>3<span class="o">]</span>    <span class="o">[</span>13<span class="o">]</span> <span class="o">[</span>57<span class="o">]</span>
</span></span></code></pre></div><ul>
<li>
<p>深度优先遍历</p>
<p>LDR LRD DLR  (左孩子优先)</p>
<p>DRL RLD RDL  (右孩子优先)</p>
<p>根据根节点的遍历顺序又可以分为先序、中序、后序遍历,其时间复杂度都是O(n)</p>
</li>
<li>
<p>广度优先遍历</p>
<ol>
<li>
<p>将根节点入队列</p>
</li>
<li>
<p>判断队列是否为空</p>
<ul>
<li>
<p>空：结束</p>
</li>
<li>
<p>非空：</p>
<ul>
<li>
<p>出队列</p>
</li>
<li>
<p>遍历该节点</p>
</li>
<li>
<p>判断该节点是否有左孩子，有则入队</p>
</li>
<li>
<p>判断该节点是否有右孩子，有则入队</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>返回第二步</p>
</li>
</ol>
<p>不变式：<strong>当上一层所有节点出队列时，队列中放的是下一层的所有节点</strong></p>
</li>
</ul>
</li>
<li>
<p>二叉树的删除</p>
<ol>
<li>
<p>要删除的节点的度为0</p>
</li>
<li>
<p>要删除的节点的度为1</p>
</li>
<li>
<p>要删除的节点的度为2</p>
</li>
</ol>
</li>
<li>
<p>BST的性能分析</p>
<p>h表示树高</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>性能</th>
</tr>
</thead>
<tbody>
<tr>
<td>查找(search)</td>
<td>O(h)</td>
</tr>
<tr>
<td>插入(insert)</td>
<td>O(h)</td>
</tr>
<tr>
<td>删除(delete)</td>
<td>O(h)</td>
</tr>
<tr>
<td>遍历</td>
<td>O(n)</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Q：一棵二叉树，有n个节点，高度的取值范围是多少？</p>
<p>A：(Log2n,n]</p>
<p>Q：一棵二叉树，有n个节点，高度最低是多少？</p>
<p>A：完全二叉树高度最低</p>
<p>Q：一颗有n个节点的完全二叉树，高度h是多少</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">          <span class="o">[]</span>      2^0
</span></span><span class="line"><span class="cl">         <span class="o">[][]</span>     2^1
</span></span><span class="line"><span class="cl">       <span class="o">[][][][]</span>   2^h
</span></span></code></pre></div><p>Q：一棵高度为h的完全二叉树，其节点数目范围是多少</p>
<p>A：2^0+2^1+···+2^(h-1)  &lt;= n &lt; 2^0+2^1+···+2^(h-1) +1</p>
<p>​                                  2^h   &lt;= n &lt; 2^(h)+1</p>
<p>​                      log2n-1&lt; h   &lt;= log2n</p>
</li>
</ul>
<h3 id="平衡二叉搜索树">平衡二叉搜索树</h3>
<p>分类</p>
<ul>
<li>AVL：对任意一个节点，左子树和右子树的高度之差不会超过1
<ul>
<li>定义很严格</li>
<li>每次添加或删除需要的调整比较多</li>
</ul>
</li>
<li>红黑树：平衡，整棵树的高度O(lgn)</li>
</ul>
<h2 id="红黑树">红黑树</h2>
<h3 id="模型-4">模型</h3>
<p>由<em>Robert</em> Sedgewick提出，红黑树是2-3-4树的实现，是4阶B树</p>
<p>java的TreeMap、C中的ordermap、linux中的epoll都是红黑树</p>
<p>Q1：如何表示3-node和4-node</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="o">[</span>   <span class="o">]</span>      <span class="o">[]</span>     <span class="o">[</span> <span class="o">]</span>
</span></span><span class="line"><span class="cl">  / <span class="p">|</span> <span class="se">\ </span>    <span class="o">[]</span> <span class="se">\ </span>   / <span class="o">[]</span>
</span></span><span class="line"><span class="cl">            /<span class="se">\ </span>        <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>            
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="o">[</span>     <span class="o">]</span>       <span class="o">[</span> <span class="o">]</span>     
</span></span><span class="line"><span class="cl">  / <span class="p">|</span> <span class="p">|</span> <span class="se">\ </span>      / <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>              <span class="o">[</span> <span class="o">]</span> <span class="o">[</span> <span class="o">]</span>    
</span></span><span class="line"><span class="cl">              / <span class="se">\ </span>/ <span class="se">\ </span>      
</span></span></code></pre></div><p>不能有两条连续的红色边表示四节点，是为了控制整棵树的高度</p>
<p>Q2：“边”是一个逻辑结构是不存在的，是不存在的，如何表示边的颜色？</p>
<p>A：应该用孩子节点的颜色来表示，父节点表示不清楚是那个孩子的；</p>
<h3 id="基本操作-4">基本操作</h3>
<p>和BST一样</p>
<h3 id="应用-4">应用</h3>
<ul>
<li>
<p>有序数组</p>
<table>
<thead>
<tr>
<th style="text-align:center">操作</th>
<th style="text-align:center">性能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">增</td>
<td style="text-align:center">O(n)</td>
</tr>
<tr>
<td style="text-align:center">删</td>
<td style="text-align:center">O(n)</td>
</tr>
<tr>
<td style="text-align:center">查</td>
<td style="text-align:center">O(logn)</td>
</tr>
<tr>
<td style="text-align:center">遍历</td>
<td style="text-align:center">O(n)</td>
</tr>
</tbody>
</table>
<p>有序数组性能不如二叉搜索树，保证有序性，存储静态数据</p>
</li>
<li>
<p>保证有序性，需要动态添加和删除元素时，可以考虑BST</p>
</li>
</ul>
<h2 id="二分查找">二分查找</h2>
<h3 id="前提">前提：</h3>
<ol>
<li>数组</li>
<li>有序：通过一次比较，可以丢掉几乎一半的区间</li>
<li>作用：减少了比较的操作次数</li>
</ol>
<p>性能：</p>
<ul>
<li>
<p>O(log n)</p>
</li>
<li>
<p>本质是减少比较的次数</p>
</li>
</ul>
<h3 id="实现-5">实现</h3>
<p>两种思路：</p>
<ul>
<li>递归</li>
<li>循环</li>
</ul>
<p>变种：</p>
<p>二分查找的变种很多：</p>
<ul>
<li>查找第一个和key值相等的元素</li>
<li>查找最后一个和key值相等的元素</li>
<li>查找第一个大于等于key值相等的元素</li>
<li>查找最后一个小于等于key值的元素</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#define SIZE(a) (sizeof(a)/sizeof(a[0]))
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">bsearch</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right</span><span class="p">,</span> <span class="kt">int</span> <span class="n">key</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//边界条件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">left</span> <span class="o">&gt;</span> <span class="n">right</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">//递归公式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">cmp</span> <span class="o">=</span> <span class="n">key</span> <span class="o">-</span> <span class="n">arr</span><span class="p">[</span><span class="n">mid</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">cmp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nf">bsearch</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">cmp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nf">bsearch</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">mid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//递归方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">binary_search1</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">key</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//闭区间：[0,n-1]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nf">bsearch</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//循环方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">binary_search2</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">key</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//闭区间：[0,n-1]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">){</span><span class="c1">//注意事项1：left &lt;= right注意等号要不要加
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>   <span class="c1">//注意事项2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">cmp</span> <span class="o">=</span> <span class="n">key</span> <span class="o">-</span> <span class="n">arr</span><span class="p">[</span><span class="n">mid</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span> <span class="n">cmp</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>   <span class="c1">//注意事项3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">cmp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>   <span class="c1">//注意事项4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">mid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span><span class="c1">//left &gt; right
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//查找第一个和key值相等的元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">binary_search3</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">key</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//闭区间：[0,n-1]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">){</span><span class="c1">//注意事项1：left &lt;= right注意等号要不要加
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>   <span class="c1">//注意事项2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">cmp</span> <span class="o">=</span> <span class="n">key</span> <span class="o">-</span> <span class="n">arr</span><span class="p">[</span><span class="n">mid</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span> <span class="n">cmp</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>   <span class="c1">//注意事项3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">cmp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>   <span class="c1">//注意事项4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//if(是第一个和key相等的元素){
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span><span class="p">(</span><span class="n">mid</span> <span class="o">==</span> <span class="n">left</span> <span class="o">||</span> <span class="n">arr</span><span class="p">[</span><span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">key</span><span class="p">){</span>  
</span></span><span class="line"><span class="cl">            	<span class="k">return</span> <span class="n">mid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span><span class="c1">//left &gt; right
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//查找第一个大于等于key值相等的元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">binary_search4</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">key</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//闭区间：[0,n-1]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">){</span><span class="c1">//注意事项1：left &lt;= right注意等号要不要加
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>   <span class="c1">//注意事项2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">cmp</span> <span class="o">=</span> <span class="n">key</span> <span class="o">-</span> <span class="n">arr</span><span class="p">[</span><span class="n">mid</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span> <span class="n">cmp</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="err">时第一个大于等于</span><span class="n">key的元素</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="n">mid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span><span class="c1">//left &gt; right
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">90</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="排序算法">排序算法</h2>
<p>如何分析一个排序算法：</p>
<ol>
<li>
<p>时间复杂度</p>
<ul>
<li>最好情况</li>
<li>最坏情况</li>
<li>平均情况</li>
</ul>
</li>
<li>
<p>空间复杂度：原地排序为O(1)</p>
</li>
<li>
<p><strong>稳定性</strong>：数据集中相等的元素，排序前后相对次序不变，则稳定</p>
<p>例如处理订单排序：首先按照下单时间排序，再按照金额排序（具有稳定性的算法）</p>
</li>
</ol>
<h3 id="选择排序">选择排序</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="m">16</span> <span class="m">1</span> <span class="m">45</span> <span class="m">23</span> <span class="m">99</span> <span class="m">2</span> <span class="m">18</span> <span class="m">67</span> <span class="m">42</span> <span class="m">10</span>
</span></span><span class="line"><span class="cl">i  min_idx
</span></span></code></pre></div><ul>
<li>
<p>从未排序的元素开始遍历，用min_index记录最小的元素的索引</p>
</li>
<li>
<p>交换</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="nf">swap</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">min_idx</span><span class="p">]);</span>
</span></span></code></pre></div></li>
<li>
<p>i向后移并且重新向后遍历</p>
</li>
</ul>
<p>时间复杂度：</p>
<ul>
<li>
<p>任何情况下都是O(n^2)</p>
</li>
<li>
<p>比较：
</p>
$$
  n(n-1) + ··· + 1 = \frac{n(n-1)}{2}
  $$
</li>
<li>
<p>交换次数：n-1</p>
</li>
</ul>
<p>空间复杂度：O(1)</p>
<p>稳定性：不稳定</p>
<h3 id="冒泡排序">冒泡排序</h3>
<ul>
<li>
<p>顺序对</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">i</span><span class="o">&lt;</span><span class="n">j</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;</span><span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
</span></span></code></pre></div></li>
<li>
<p>逆序对</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">i</span><span class="o">&lt;</span><span class="n">j</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
</span></span></code></pre></div></li>
</ul>
<p>排序的过程就是让逆序对的数量变为零，经历过一轮操作，小元素会慢慢地浮到数组的前面，<strong>而整个数组最大的元素在最末尾</strong></p>
<p>优点：冒泡排序可以提前感知到数组是否有序</p>
<p><strong>时间复杂度</strong>：</p>
<ul>
<li>最好和最坏情况</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">最好情况</th>
<th style="text-align:center">最坏情况</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">数组状态</td>
<td style="text-align:center">原数组有序</td>
<td style="text-align:center">原数组逆序</td>
</tr>
<tr>
<td style="text-align:center">比较次数</td>
<td style="text-align:center">n-1</td>
<td style="text-align:center">n(n-1)/2</td>
</tr>
<tr>
<td style="text-align:center">交换次数</td>
<td style="text-align:center">0</td>
<td style="text-align:center">n(n-1)/2</td>
</tr>
<tr>
<td style="text-align:center">时间复杂度</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(n^2)</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>平均时间复杂度
</p>
$$
  交换次数=逆序对 = \frac{n(n-1)}{4}  \\
  交换次数<=比较次数<=\frac{n(n-1)}{2}
  $$
</li>
<li>
<p>空间复杂度:O(1)</p>
</li>
<li>
<p>稳定性：稳定</p>
</li>
</ul>
<h3 id="插入排序">插入排序</h3>
<p>类比打牌时的理牌过程，从无序区按顺序找第一张牌（value），在有序区<strong>从后往前</strong>找到第一个<strong>小于等于</strong>value的元素,插入到该元素的后面</p>
<h4 id="实现-6">实现</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">insertion_sort</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//i表示要插入元素的索引
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span><span class="p">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">value</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">];</span> 
</span></span><span class="line"><span class="cl">            <span class="n">j</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>  <span class="c1">//j == 1 || arr[j] &lt;=value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">print_array</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">print_array</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d &#34;</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">5</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="分析">分析</h4>
<p>时间：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">最好情况</th>
<th style="text-align:center">最坏情况</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">数组状态</td>
<td style="text-align:center">原数组有序</td>
<td style="text-align:center">原数组逆序</td>
</tr>
<tr>
<td style="text-align:center">比较次数</td>
<td style="text-align:center">n-1</td>
<td style="text-align:center">n(n-1)/2</td>
</tr>
<tr>
<td style="text-align:center">交换次数</td>
<td style="text-align:center">0</td>
<td style="text-align:center">n(n-1)/2</td>
</tr>
<tr>
<td style="text-align:center">时间复杂度</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(n^2)</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>平均时间复杂度
</p>
$$
  逆序时：逆序对 = 顺序对 = \frac{C_{n}^{2}}{2} = \frac{(n-1)}{4}
  $$
$$
  比较：大于等于比较次数，小于等于 \frac{n(n-1)}{2}
  $$
</li>
</ul>
$$
平均时间复杂度复杂度 = O(n^2)
$$
<p>空间</p>
<ul>
<li>空间复杂度：0(1)</li>
<li>稳定性：稳定（交换相邻元素，能够保证原先的次序）</li>
</ul>
<h4 id="应用-5">应用</h4>
<ol>
<li>数组长度比较小</li>
<li>原数组基本有序时（离最终的位置很近），插入排序可以在O(1)的时间内完成排序</li>
</ol>
<h3 id="希尔排序">希尔排序</h3>
<p>插入排序的简单扩展，n=10, gap= 5, 2, 1, 0;</p>
<p><strong>循环过程</strong>：</p>
<ul>
<li>
<p>多个人抓牌，自己理牌</p>
</li>
<li>
<p>gap/2，抓牌人变少</p>
</li>
</ul>
<p>到最后只剩下一个人拽牌，变成了简单的插入排序，最后一轮的时间复杂度为O(n)</p>
<h4 id="实现-7">实现</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">shell_sort</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//gap序列：n/2,n/4;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">gap</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">gap</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//组件插入排序(gap个人轮流抓牌)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">gap</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//排堆，（gap,n）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//保证自己的手牌有序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>           	<span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">gap</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">while</span><span class="p">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">value</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="n">gap</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                <span class="n">j</span> <span class="o">-</span> <span class="o">=</span> <span class="n">gap</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span><span class="c1">// j &lt; 0 || arr[j]&lt;=value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="n">gap</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//查看流程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    	<span class="nf">print_array</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    	<span class="n">gap</span> <span class="o">&gt;&gt;=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">gap</span> <span class="o">&gt;&gt;</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>优点</strong>：</p>
<ul>
<li>长距离优化，可以减少交换的次数</li>
</ul>
<p>分析：</p>
<ul>
<li>
<p>时间复杂度：
</p>
$$
  和gap序列相关，一般来说，平均情况小于O(n^2)
  $$
</li>
<li>
<p>空间复杂度：O(1)</p>
</li>
<li>
<p>稳定性：</p>
<p>不稳定（发生长距离的交换，牺牲了稳定性，换取了时间）</p>
</li>
</ul>
<h3 id="归并排序">归并排序</h3>
<p>分治思想：一般通过递归实现</p>
<p><strong>步骤</strong>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">            <span class="o">[</span>38<span class="o">][</span>27<span class="o">][</span>43<span class="o">][</span>3<span class="o">][</span>9<span class="o">][</span>82<span class="o">][</span>10<span class="o">]</span>         O<span class="o">(</span>n<span class="o">)</span>
</span></span><span class="line"><span class="cl">··· 递
</span></span><span class="line"><span class="cl">         <span class="o">[</span>38<span class="o">][</span>27<span class="o">][</span>43<span class="o">][</span>3<span class="o">]</span>       <span class="o">[</span>9<span class="o">][</span>82<span class="o">][</span>10<span class="o">]</span>       O<span class="o">(</span>n<span class="o">)</span>
</span></span><span class="line"><span class="cl">          
</span></span><span class="line"><span class="cl">       <span class="o">[</span>38<span class="o">][</span>27<span class="o">]</span>  <span class="o">[</span>43<span class="o">][</span>3<span class="o">]</span>     <span class="o">[</span>9<span class="o">][</span>82<span class="o">]</span>   <span class="o">[</span>10<span class="o">]</span>       O<span class="o">(</span>n<span class="o">)</span>
</span></span><span class="line"><span class="cl">       
</span></span><span class="line"><span class="cl">     <span class="o">[</span>38<span class="o">]</span>  <span class="o">[</span>27<span class="o">]</span>  <span class="o">[</span>43<span class="o">]</span>  <span class="o">[</span>3<span class="o">]</span>  <span class="o">[</span>9<span class="o">]</span>  <span class="o">[</span>82<span class="o">]</span>   <span class="o">[</span>10<span class="o">]</span>       O<span class="o">(</span>n<span class="o">)</span>
</span></span><span class="line"><span class="cl">···· merge
</span></span><span class="line"><span class="cl">       <span class="o">[</span>27<span class="o">][</span>38<span class="o">]</span>  <span class="o">[</span>3<span class="o">][</span>43<span class="o">]</span>     <span class="o">[</span>9<span class="o">][</span>82<span class="o">]</span>   <span class="o">[</span>10<span class="o">]</span>        O<span class="o">(</span>n<span class="o">)</span>
</span></span><span class="line"><span class="cl">       
</span></span><span class="line"><span class="cl">         <span class="o">[</span>3<span class="o">][</span>27<span class="o">][</span>38<span class="o">][</span>43<span class="o">]</span>       <span class="o">[</span>9<span class="o">][</span>10<span class="o">][</span>82<span class="o">]</span>        O<span class="o">(</span>n<span class="o">)</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="o">[</span>3<span class="o">][</span>9<span class="o">][</span>10<span class="o">][</span>27<span class="o">][</span>38<span class="o">][</span>43<span class="o">][</span>82<span class="o">]</span>          O<span class="o">(</span>n<span class="o">)</span>
</span></span></code></pre></div><p><strong>实现</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define SIZE(a) (sizeof(a)/sizeof(a[]))
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">print_array</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d &#34;</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">tmp</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 左：[left, mid]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 右：[mid+1,right]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">left</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   	
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">mid</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]){</span>
</span></span><span class="line"><span class="cl">            <span class="n">tmp</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">tmp</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">mid</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">tmp</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">tmp</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">//将tmp数组的对应区间，复制到arr数组中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">arr</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">m_sort</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//边界条件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">left</span> <span class="o">&gt;=</span> <span class="n">right</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//递归公式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//对左边区间进行排序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">m_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//对右边区间排序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">m_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//归并操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">merge</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">merge_sort</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="nf">m_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
</span></span><span class="line"><span class="cl"> 	<span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">38</span><span class="p">,</span> <span class="mi">27</span><span class="p">,</span> <span class="mi">43</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">83</span><span class="p">,</span> <span class="mi">20</span><span class="p">};</span>   
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>时间复杂度</strong></p>
$$
T(n) = 2 T\frac{n}{2} + O(n)  \\
T(n) = log_2n·O(n) = O(nlog_2n)=O(nlogn)
$$
<ul>
<li>
<p>对于递归算法尝试用递归树分析时间复杂度</p>
</li>
<li>
<p>归并排序对数据不敏感，任何情况都是O(nlogn)</p>
</li>
</ul>
<p><strong>空间复杂度</strong>：
</p>
$$
O(logn)+O(n) = O(n)
$$
<p><strong>稳定性</strong>： 稳定</p>
<h3 id="快速排序">快速排序</h3>
<p><strong>算法步骤</strong></p>
<ol>
<li>
<p>partition：分区</p>
<p>选取一个基准值：Pivot</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">[</span>&lt;<span class="o">=</span>pivot<span class="o">][</span>p<span class="o">][</span>&gt;<span class="o">=</span>pivot<span class="o">]</span>
</span></span><span class="line"><span class="cl">          ^    
</span></span><span class="line"><span class="cl">        pivot
</span></span></code></pre></div></li>
<li>
<p>对左边进行快速排序</p>
</li>
<li>
<p>对右边进行快速排序</p>
</li>
</ol>
<p>递归执行上述操作</p>
<h4 id="实现-8">实现</h4>
<p>关键是如何实现分区算法</p>
<ul>
<li>
<p>a.单向分区</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">store
</span></span><span class="line"><span class="cl">  <span class="p">|</span>
</span></span><span class="line"><span class="cl">  <span class="m">3</span> <span class="m">7</span> <span class="m">8</span> <span class="m">5</span> <span class="m">2</span> <span class="m">1</span> <span class="m">9</span> <span class="m">5</span> <span class="m">4</span>
</span></span><span class="line"><span class="cl">  <span class="p">|</span>
</span></span><span class="line"><span class="cl">  i
</span></span></code></pre></div><p>选择最右边的元素作为基准值:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nv">pivot</span> <span class="o">=</span> <span class="m">4</span>
</span></span></code></pre></div><p>两个索引的作用:</p>
<ul>
<li>
<p>store:下一个&lt;=pivot的元素应该放置的位置</p>
</li>
<li>
<p>i: 用于遍历所有的元素</p>
</li>
</ul>
<p>单向分区的不变式</p>
$$
  [o,store)<= pivot，满足条件\\
  遍历时，[store, i) > pivot，不满足条件 \\
  终止 i = n-1
  $$
<p>
<strong>平均操作次数：</strong>
</p>
$$
  \frac{n}{2}·3=1.5n (赋值)
  $$
</li>
<li>
<p>b.双向分区</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  <span class="m">3</span> <span class="m">7</span> <span class="m">8</span> <span class="m">5</span> <span class="m">2</span> <span class="m">1</span> <span class="m">9</span> <span class="m">5</span> <span class="m">4</span>
</span></span><span class="line"><span class="cl">  <span class="p">|</span>               <span class="p">|</span>
</span></span><span class="line"><span class="cl">  i               j
</span></span></code></pre></div><p>选择pivot = 3</p>
<p><strong>两个索引的作用：</strong></p>
<ul>
<li>i：下一个&lt;=pivot的元素置于的位置</li>
<li>j：下一个&gt;=pivot的元素置于的位置</li>
</ul>
<p>双向分区的不变式</p>
$$
  [o,)<= pivot，满足条件\\
  [j, n-1) >= pivot，不满足条件 \\
  $$
<p>
<strong>平均操作次数：</strong>
</p>
$$
  \frac{n}{2}·1=0.5n (赋值)
  $$
</li>
<li>
<p>c.三向分区</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">[</span>&lt;<span class="o">=</span>pivot<span class="o">][</span>p<span class="o">][</span>&gt;<span class="o">=</span>pivot<span class="o">]</span>
</span></span><span class="line"><span class="cl">          ^    
</span></span><span class="line"><span class="cl">        pivot
</span></span></code></pre></div><p>相同元素比较多的情况下才使用三项分区</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define SIZE(a) (sizeof(a)/sizeof(a[0]))
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">partition</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//1.选取基准值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">pivot</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">left</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//2. 双向分区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">left</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 先移动j，找&lt;pivot的元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">pivot</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">j</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span><span class="c1">// i == j || arr[j] &lt; pivot
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">//再移动i，找&gt;pivot的元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">pivot</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">i</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span><span class="c1">// i == j || arr[j] &lt; pivot
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="c1">// i == j
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pivot</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">q_sort</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//边界条件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">left</span> <span class="o">&gt;=</span> <span class="n">right</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//递归公式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//1.分区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="nf">partition</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//2.对左边区间进行排序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">q_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">idx</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//3.对右边区间排序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">q_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">quick_sort</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//通过委托实现
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">q_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span>    
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="分析-1">分析</h4>
<p>时间：</p>
<ul>
<li>
<p>最好情况 O(nlogn)</p>
<p>每次分区基准值都在中间
</p>
$$
  T(n) = O(n) + T(\frac{n}{2})+T(\frac{n}{2})\\
  = O(n) + 2·T(\frac{n}{2})\\
  =O(n·logn)
  $$
</li>
<li>
<p>最坏情况 O(n^2)</p>
<p>每次分区，基准值都位于两边
</p>
$$
  T(n) = c·n+c·(n-1)+···+c·2+c = c·\frac{n·(n-1)}{2}=O(n^2)
  $$
</li>
<li>
<p>平均复杂度 O(n·logn)</p>
<p>假定每次分区，都分成大约为9：1的区间
</p>
$$
  T(n) <= log_\frac{10}{9}n·c·n=O(nlogn)
  $$
</li>
</ul>
<p>空间：O(logn)</p>
<p>稳定性：不稳定</p>
<h4 id="改进策略">改进策略</h4>
<ul>
<li>
<p>选取基准值</p>
<ul>
<li>随机选取</li>
<li>选取3到5个元素，选取其中位数</li>
</ul>
</li>
<li>
<p>当区间长度小于某个值(&lt;=32， 64)，改用插入排序</p>
</li>
<li>
<p>改分区算法</p>
<p>当重复元素比较多时，可以选择使用三向分区算法</p>
</li>
</ul>
<h3 id="堆排序">堆排序</h3>
<p>二叉堆：实质上是一棵二叉树</p>
<ul>
<li>大顶堆：左右子树的key都小于根节点，并且左右子树都是大顶堆</li>
<li>小顶堆：左右子树的key都大于根节点，并且左右子树都是小顶堆</li>
</ul>
<p>算法步骤：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">数组 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="m">16</span> <span class="m">1</span> <span class="m">45</span> <span class="m">23</span> <span class="m">99</span> <span class="m">2</span> <span class="m">18</span> <span class="m">67</span> <span class="m">42</span> <span class="m">10</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">将数组看作一颗二叉树
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          <span class="m">16</span>
</span></span><span class="line"><span class="cl">       /      <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>      <span class="m">1</span>        <span class="m">45</span>
</span></span><span class="line"><span class="cl">    /   <span class="se">\ </span>     /  <span class="se">\ </span> 
</span></span><span class="line"><span class="cl">   <span class="m">23</span>    <span class="m">99</span>   <span class="m">2</span>   <span class="m">18</span>
</span></span><span class="line"><span class="cl">  / <span class="se">\ </span>   /
</span></span><span class="line"><span class="cl"> <span class="m">67</span>  <span class="m">42</span> <span class="m">10</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"> parent<span class="o">(</span>i<span class="o">)</span> <span class="o">=</span> <span class="o">(</span>i-1<span class="o">)</span>/2
</span></span><span class="line"><span class="cl"> lchild<span class="o">(</span>i<span class="o">)</span> <span class="o">=</span> 2i+1
</span></span><span class="line"><span class="cl"> rchild<span class="o">(</span>i<span class="o">)</span> <span class="o">=</span> 2i+2
</span></span></code></pre></div><ol>
<li>
<p>构建大顶堆</p>
<p>从后往前构建大顶堆（能够保证左右子树都是大顶堆）</p>
</li>
<li>
<p>无序区length = n</p>
<p>交换堆顶元素和无序区的最后一个元素</p>
<p>无序区的长度length&ndash;</p>
<p>重新调整成大顶堆</p>
</li>
<li>
<p>直到无序区的长度为1为止</p>
</li>
</ol>
<h4 id="实现-9">实现</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define SIZE(a) (sizeof(a)/sizeof(a[0]))
</span></span></span><span class="line"><span class="cl"><span class="cp">#define SWAP(arr, i, j){ \
</span></span></span><span class="line"><span class="cl"><span class="cp">	int t = arr[i];
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>	<span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">heapify</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 求三个元素的最大值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">lchild</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">rchild</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">maxId</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">lchild</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="p">[</span><span class="n">lchild</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">maxIdx</span><span class="p">]){</span>
</span></span><span class="line"><span class="cl">            <span class="n">maxIdx</span> <span class="o">=</span> <span class="n">lchild</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">rchild</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="p">[</span><span class="n">rchild</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">maxIdx</span><span class="p">]){</span>
</span></span><span class="line"><span class="cl">        	<span class="n">maxIdx</span> <span class="o">=</span> <span class="n">rchild</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//如果最大值是根节点，调整结束
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="n">maxIdx</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//如果不是，交换根节点和最大直接点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">SWAP</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">maxIdx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//调整maxIdx节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">i</span> <span class="o">=</span> <span class="n">maxIdx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">build_heap</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//从后往前依次构建大顶堆
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//找到第一个非叶子节点: lchild(i) = 2i+1 &lt;= n -1; =&gt; i&lt;= ( n - 2 &gt;&gt; 1)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="p">(</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nf">heapify</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">heap_sort</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//1.构建大顶堆
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">build_heap</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>　　　
</span></span><span class="line"><span class="cl">    <span class="nf">print_array</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//2.初始化无序区的长度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//3.交换堆顶元素和无序区最后一个元素,直到len == 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nf">SWAP</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">len</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nf">heapify</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">print_array</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="分析-2">分析</h4>
<ul>
<li>
<p>时间复杂度：对数据不敏感</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="nf">build_heap</span><span class="p">()</span>  <span class="err">复杂度为</span><span class="n">O</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</span></span></code></pre></div>$$
  调整次数=2^0·h+2^1·(h-1)+2^2·(h-2)+···+·2^{h-1}·1\\
  =2^1·h+2^2·(h-1)+···+2^{h-1}·2+2^h·1\\
  =2^0·h+(2^1+2^2+···+2{h-1}+2{h})\\
  = 2^{h+1}-2-h\\
  =2·n-2-log_2n\\
  $$
$$
  T(n) = O(n)+(n-1)·O(logn) = O(nlogn)
  $$
</li>
<li>
<p>空间复杂度：O(1)</p>
</li>
<li>
<p>稳定性：稳定</p>
</li>
</ul>
<h2 id="如何设计一个通用的排序算法">如何设计一个通用的排序算法</h2>
<table>
<thead>
<tr>
<th style="text-align:center">数据量</th>
<th style="text-align:center">方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">数据量少</td>
<td style="text-align:center">插入排序</td>
</tr>
<tr>
<td style="text-align:center">数据量大</td>
<td style="text-align:center">快速排序</td>
</tr>
<tr>
<td style="text-align:center">数据量大&amp;&amp;需要稳定性</td>
<td style="text-align:center">堆排序</td>
</tr>
</tbody>
</table>
</article>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>
</div>
<script type="application/javascript" src='https://looechao.github.io/js/toc.js'></script>
<link rel="stylesheet" href='https://looechao.github.io/css/toc.css' />


<div id="gitalk-container" class="gitalk-container"></div>
<link rel="stylesheet" href='https://looechao.github.io/css/gitalk.css'>
<script src='https://looechao.github.io/js/gitalk.min.js'></script>
<script>
  const gitalk = new Gitalk({
    clientID: '4fad9f9325f73f2c2891',
    clientSecret: '109ed02ced3608e776a41f87de4ef9986f5b5fd6',
    repo: 'hugo-comments',
    owner: 'looechao',
    admin: ['looechao'],
    id: eval("location.pathname"), 
    distractionFreeMode: false 
  });
  (function() {
    gitalk.render('gitalk-container');
  })();
</script>


  <div class="footer container-xl width-full p-responsive">
  <div
    class="position-relative d-flex flex-row-reverse flex-lg-row flex-wrap flex-lg-nowrap flex-justify-center flex-lg-justify-between flex-sm-items-center pt-6 pb-2 mt-6 f6 text-gray border-top border-gray-light ">
    <a aria-label="Homepage" title="GitHub" class="footer-octicon d-none d-lg-block mr-lg-4" href="https://looechao.github.io/">
      <svg height="24" class="octicon octicon-mark-github" viewBox="0 0 16 16" version="1.1" width="24">
        <path fill-rule="evenodd"
          d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z">
        </path>
      </svg>
    </a>
    <ul class="list-style-none d-flex flex-wrap col-12 flex-justify-center flex-lg-justify-between mb-2 mb-lg-0">
      
      <li class="mr-3 mr-lg-0">Theme by <a href='https://github.com/MeiK2333/github-style'>github-style</a></li>
      
    </ul>
  </div>
  <div class="d-flex flex-justify-center pb-6">
    <span class="f6 text-gray-light"></span>
  </div>


</div>
</body>

<script type="application/javascript" src="https://looechao.github.io/js/github-style.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css"
  integrity="sha384-wcIxkf4k558AjM3Yz3BBFQUbk/zgIYC2R0QpeeYb+TwlBVMrlgLqwRjRtGZiK7ww" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js"
  integrity="sha384-hIoBPJpTUs74ddyc4bFZSM1TVlQDA60VBbJS0oA934VSz82sBx1X7kSx2ATBDIyd" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js"
  integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>





</html>